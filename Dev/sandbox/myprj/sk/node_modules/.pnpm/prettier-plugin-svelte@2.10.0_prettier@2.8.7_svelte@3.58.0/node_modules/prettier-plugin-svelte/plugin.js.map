{"version":3,"file":"plugin.js","sources":["src/lib/elements.ts","src/lib/extractAttributes.ts","src/lib/snipTagContent.ts","src/lib/getText.ts","src/options.ts","src/print/helpers.ts","src/print/doc-helpers.ts","src/print/node-helpers.ts","src/print/index.ts","src/embed.ts","src/index.ts"],"sourcesContent":["export type TagName = keyof HTMLElementTagNameMap | 'svg';\r\n\r\n// @see http://xahlee.info/js/html5_non-closing_tag.html\r\nexport const selfClosingTags = [\r\n    'area',\r\n    'base',\r\n    'br',\r\n    'col',\r\n    'embed',\r\n    'hr',\r\n    'img',\r\n    'input',\r\n    'link',\r\n    'meta',\r\n    'param',\r\n    'source',\r\n    'track',\r\n    'wbr',\r\n];\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements#Elements\r\nexport const blockElements: TagName[] = [\r\n    'address',\r\n    'article',\r\n    'aside',\r\n    'blockquote',\r\n    'details',\r\n    'dialog',\r\n    'dd',\r\n    'div',\r\n    'dl',\r\n    'dt',\r\n    'fieldset',\r\n    'figcaption',\r\n    'figure',\r\n    'footer',\r\n    'form',\r\n    'h1',\r\n    'h2',\r\n    'h3',\r\n    'h4',\r\n    'h5',\r\n    'h6',\r\n    'header',\r\n    'hgroup',\r\n    'hr',\r\n    'li',\r\n    'main',\r\n    'nav',\r\n    'ol',\r\n    'p',\r\n    'pre',\r\n    'section',\r\n    'table',\r\n    'ul',\r\n];\r\n\r\n/**\r\n * HTML attributes that we may safely reformat (trim whitespace, add or remove newlines)\r\n */\r\nexport const formattableAttributes: string[] = [\r\n    // None at the moment\r\n    // Prettier HTML does not format attributes at all\r\n    // and to be consistent we leave this array empty for now\r\n];\r\n","import { AttributeNode, TextNode } from '../print/nodes';\r\n\r\nexport function extractAttributes(html: string): AttributeNode[] {\r\n    const extractAttributesRegex = /<[a-z]+[\\s\\n]*([\\s\\S]*?)>/im;\r\n    const attributeRegex = /([^\\s=]+)(?:=(?:(?:(\"|')([\\s\\S]*?)\\2)|(?:(\\S+?)(?:\\s|>|$))))?/gim;\r\n\r\n    const [, attributesString] = html.match(extractAttributesRegex)!;\r\n\r\n    const attrs: AttributeNode[] = [];\r\n\r\n    let match: RegExpMatchArray | null;\r\n    while ((match = attributeRegex.exec(attributesString))) {\r\n        const [all, name, quotes, valueQuoted, valueUnquoted] = match;\r\n        const value = valueQuoted || valueUnquoted;\r\n        const attrStart = match.index!;\r\n\r\n        let valueNode: AttributeNode['value'];\r\n        if (!value) {\r\n            valueNode = true;\r\n        } else {\r\n            let valueStart = attrStart + name.length;\r\n            if (quotes) {\r\n                valueStart += 2;\r\n            }\r\n\r\n            valueNode = [\r\n                {\r\n                    type: 'Text',\r\n                    data: value,\r\n                    start: valueStart,\r\n                    end: valueStart + value.length,\r\n                } as TextNode,\r\n            ];\r\n        }\r\n\r\n        attrs.push({\r\n            type: 'Attribute',\r\n            name,\r\n            value: valueNode,\r\n            start: attrStart,\r\n            end: attrStart + all.length,\r\n        });\r\n    }\r\n\r\n    return attrs;\r\n}\r\n","export const snippedTagContentAttribute = '✂prettier:content✂';\r\n\r\nexport function snipScriptAndStyleTagContent(source: string): string {\r\n    let scriptMatchSpans = getMatchIndexes('script');\r\n    let styleMatchSpans = getMatchIndexes('style');\r\n\r\n    return snipTagContent(\r\n        snipTagContent(source, 'script', '{}', styleMatchSpans),\r\n        'style',\r\n        '',\r\n        scriptMatchSpans,\r\n    );\r\n\r\n    function getMatchIndexes(tagName: string) {\r\n        const regex = getRegexp(tagName);\r\n        const indexes: [number, number][] = [];\r\n        let match = null;\r\n        while ((match = regex.exec(source)) != null) {\r\n            if (source.slice(match.index, match.index + 4) !== '<!--') {\r\n                indexes.push([match.index, regex.lastIndex]);\r\n            }\r\n        }\r\n        return indexes;\r\n    }\r\n\r\n    function snipTagContent(\r\n        _source: string,\r\n        tagName: string,\r\n        placeholder: string,\r\n        otherSpans: [number, number][],\r\n    ) {\r\n        const regex = getRegexp(tagName);\r\n        let newScriptMatchSpans = scriptMatchSpans;\r\n        let newStyleMatchSpans = styleMatchSpans;\r\n        // Replace valid matches\r\n        const newSource = _source.replace(regex, (match, attributes, content, index) => {\r\n            if (match.startsWith('<!--') || withinOtherSpan(index)) {\r\n                return match;\r\n            }\r\n            const encodedContent = Buffer.from(content).toString('base64');\r\n            const newContent = `<${tagName}${attributes} ${snippedTagContentAttribute}=\"${encodedContent}\">${placeholder}</${tagName}>`;\r\n\r\n            // Adjust the spans because the source now has a different content length\r\n            const lengthDiff = match.length - newContent.length;\r\n            newScriptMatchSpans = adjustSpans(scriptMatchSpans, newScriptMatchSpans);\r\n            newStyleMatchSpans = adjustSpans(styleMatchSpans, newStyleMatchSpans);\r\n            function adjustSpans(\r\n                oldSpans: [number, number][],\r\n                newSpans: [number, number][],\r\n            ): [number, number][] {\r\n                return oldSpans.map((oldSpan, idx) => {\r\n                    const newSpan = newSpans[idx];\r\n                    // Do the check using the old spans because the replace function works\r\n                    // on the old spans. Replace oldSpans with newSpans afterwards.\r\n                    if (oldSpan[0] > index) {\r\n                        // span is after the match -> adjust start and end\r\n                        return [newSpan[0] - lengthDiff, newSpan[1] - lengthDiff];\r\n                    } else if (oldSpan[0] === index) {\r\n                        // span is the match -> adjust end only\r\n                        return [newSpan[0], newSpan[1] - lengthDiff];\r\n                    } else {\r\n                        // span is before the match -> nothing to adjust\r\n                        return newSpan;\r\n                    }\r\n                });\r\n            }\r\n\r\n            return newContent;\r\n        });\r\n\r\n        // Now that the replacement function ran, we can adjust the spans for the next run\r\n        scriptMatchSpans = newScriptMatchSpans;\r\n        styleMatchSpans = newStyleMatchSpans;\r\n\r\n        return newSource;\r\n\r\n        function withinOtherSpan(idx: number) {\r\n            return otherSpans.some((otherSpan) => idx > otherSpan[0] && idx < otherSpan[1]);\r\n        }\r\n    }\r\n\r\n    function getRegexp(tagName: string) {\r\n        return new RegExp(`<!--[^]*?-->|<${tagName}([^]*?)>([^]*?)<\\/${tagName}>`, 'g');\r\n    }\r\n}\r\n\r\nexport function hasSnippedContent(text: string) {\r\n    return text.includes(snippedTagContentAttribute);\r\n}\r\n\r\nexport function unsnipContent(text: string): string {\r\n    const regex = /(<\\w+.*?)\\s*✂prettier:content✂=\"(.*?)\">.*?(?=<\\/)/gi;\r\n\r\n    return text.replace(regex, (_, start, encodedContent) => {\r\n        const content = Buffer.from(encodedContent, 'base64').toString('utf8');\r\n        return `${start}>${content}`;\r\n    });\r\n}\r\n","import { ParserOptions } from 'prettier';\r\nimport { Node } from '../print/nodes';\r\nimport { hasSnippedContent, unsnipContent } from './snipTagContent';\r\n\r\nexport function getText(node: Node, options: ParserOptions, unsnip = false) {\r\n    const leadingComments: Node[] = (node as any).leadingComments;\r\n    const text = options.originalText.slice(\r\n        options.locStart(\r\n            // if there are comments before the node they are not included\r\n            // in the `start` of the node itself\r\n            (leadingComments && leadingComments[0]) || node,\r\n        ),\r\n        options.locEnd(node),\r\n    );\r\n\r\n    if (!unsnip || !hasSnippedContent(text)) {\r\n        return text;\r\n    }\r\n\r\n    return unsnipContent(text);\r\n}\r\n","import { ParserOptions, SupportOption } from 'prettier';\r\n\r\ndeclare module 'prettier' {\r\n    interface RequiredOptions extends PluginOptions {}\r\n}\r\n\r\nexport interface PluginOptions {\r\n    svelteSortOrder: SortOrder;\r\n    svelteStrictMode: boolean;\r\n    svelteBracketNewLine: boolean;\r\n    svelteAllowShorthand: boolean;\r\n    svelteIndentScriptAndStyle: boolean;\r\n}\r\n\r\nfunction makeChoice(choice: string) {\r\n    return { value: choice, description: choice };\r\n}\r\n\r\nexport const options: Record<keyof PluginOptions, SupportOption> = {\r\n    svelteSortOrder: {\r\n        since: '0.6.0',\r\n        category: 'Svelte',\r\n        type: 'choice',\r\n        default: 'options-scripts-markup-styles',\r\n        description: 'Sort order for scripts, markup, and styles',\r\n        choices: [\r\n            makeChoice('options-scripts-markup-styles'),\r\n            makeChoice('options-scripts-styles-markup'),\r\n            makeChoice('options-markup-styles-scripts'),\r\n            makeChoice('options-markup-scripts-styles'),\r\n            makeChoice('options-styles-markup-scripts'),\r\n            makeChoice('options-styles-scripts-markup'),\r\n            makeChoice('scripts-options-markup-styles'),\r\n            makeChoice('scripts-options-styles-markup'),\r\n            makeChoice('markup-options-styles-scripts'),\r\n            makeChoice('markup-options-scripts-styles'),\r\n            makeChoice('styles-options-markup-scripts'),\r\n            makeChoice('styles-options-scripts-markup'),\r\n            makeChoice('scripts-markup-options-styles'),\r\n            makeChoice('scripts-styles-options-markup'),\r\n            makeChoice('markup-styles-options-scripts'),\r\n            makeChoice('markup-scripts-options-styles'),\r\n            makeChoice('styles-markup-options-scripts'),\r\n            makeChoice('styles-scripts-options-markup'),\r\n            makeChoice('scripts-markup-styles-options'),\r\n            makeChoice('scripts-styles-markup-options'),\r\n            makeChoice('markup-styles-scripts-options'),\r\n            makeChoice('markup-scripts-styles-options'),\r\n            makeChoice('styles-markup-scripts-options'),\r\n            makeChoice('styles-scripts-markup-options'),\r\n            makeChoice('none'),\r\n            // Deprecated, keep in 2.x for backwards-compatibility. svelte:options will be moved to the top\r\n            makeChoice('scripts-markup-styles'),\r\n            makeChoice('scripts-styles-markup'),\r\n            makeChoice('markup-styles-scripts'),\r\n            makeChoice('markup-scripts-styles'),\r\n            makeChoice('styles-markup-scripts'),\r\n            makeChoice('styles-scripts-markup'),\r\n        ],\r\n    },\r\n    svelteStrictMode: {\r\n        since: '0.7.0',\r\n        category: 'Svelte',\r\n        type: 'boolean',\r\n        default: false,\r\n        description: 'More strict HTML syntax: self-closed tags, quotes in attributes',\r\n    },\r\n    svelteBracketNewLine: {\r\n        since: '0.6.0',\r\n        category: 'Svelte',\r\n        type: 'boolean',\r\n        description: 'Put the `>` of a multiline element on a new line',\r\n        deprecated: '2.5.0',\r\n    },\r\n    svelteAllowShorthand: {\r\n        since: '1.0.0',\r\n        category: 'Svelte',\r\n        type: 'boolean',\r\n        default: true,\r\n        description:\r\n            'Option to enable/disable component attribute shorthand if attribute name and expressions are same',\r\n    },\r\n    svelteIndentScriptAndStyle: {\r\n        since: '1.2.0',\r\n        category: 'Svelte',\r\n        type: 'boolean',\r\n        default: true,\r\n        description:\r\n            'Whether or not to indent the code inside <script> and <style> tags in Svelte files',\r\n    },\r\n};\r\n\r\nexport type SortOrder =\r\n    | 'options-scripts-markup-styles'\r\n    | 'options-scripts-styles-markup'\r\n    | 'options-markup-styles-scripts'\r\n    | 'options-markup-scripts-styles'\r\n    | 'options-styles-markup-scripts'\r\n    | 'options-styles-scripts-markup'\r\n    | 'scripts-options-markup-styles'\r\n    | 'scripts-options-styles-markup'\r\n    | 'markup-options-styles-scripts'\r\n    | 'markup-options-scripts-styles'\r\n    | 'styles-options-markup-scripts'\r\n    | 'styles-options-scripts-markup'\r\n    | 'scripts-markup-options-styles'\r\n    | 'scripts-styles-options-markup'\r\n    | 'markup-styles-options-scripts'\r\n    | 'markup-scripts-options-styles'\r\n    | 'styles-markup-options-scripts'\r\n    | 'styles-scripts-options-markup'\r\n    | 'scripts-markup-styles-options'\r\n    | 'scripts-styles-markup-options'\r\n    | 'markup-styles-scripts-options'\r\n    | 'markup-scripts-styles-options'\r\n    | 'styles-markup-scripts-options'\r\n    | 'styles-scripts-markup-options'\r\n    | 'none'\r\n    | DeprecatedSortOrder;\r\n\r\nexport type DeprecatedSortOrder =\r\n    | 'scripts-markup-styles'\r\n    | 'scripts-styles-markup'\r\n    | 'markup-styles-scripts'\r\n    | 'markup-scripts-styles'\r\n    | 'styles-markup-scripts'\r\n    | 'styles-scripts-markup';\r\n\r\nexport type SortOrderPart = 'scripts' | 'markup' | 'styles' | 'options';\r\n\r\nconst sortOrderSeparator = '-';\r\n\r\nexport function parseSortOrder(sortOrder: SortOrder): SortOrderPart[] {\r\n    if (sortOrder === 'none') {\r\n        return [];\r\n    }\r\n\r\n    const order = sortOrder.split(sortOrderSeparator) as SortOrderPart[];\r\n    // For backwards compatibility: Add options to beginning if not present\r\n    if (!order.includes('options')) {\r\n        console.warn(\r\n            'svelteSortOrder is missing option `options`. This will be an error in prettier-plugin-svelte version 3.',\r\n        );\r\n        order.unshift('options');\r\n    }\r\n    return order;\r\n}\r\n\r\nexport function isBracketSameLine(options: ParserOptions): boolean {\r\n    return options.svelteBracketNewLine != null\r\n        ? !options.svelteBracketNewLine\r\n        : options.bracketSameLine != null\r\n        ? options.bracketSameLine\r\n        : false;\r\n}\r\n","import {\r\n    ASTNode,\r\n    AttributeNode,\r\n    BodyNode,\r\n    DocumentNode,\r\n    ElementNode,\r\n    HeadNode,\r\n    InlineComponentNode,\r\n    Node,\r\n    OptionsNode,\r\n    ScriptNode,\r\n    SlotNode,\r\n    SlotTemplateNode,\r\n    StyleNode,\r\n    TitleNode,\r\n    WindowNode,\r\n} from './nodes';\r\nimport { Doc, doc, FastPath, ParserOptions } from 'prettier';\r\nimport { formattableAttributes } from '../lib/elements';\r\nimport { PrintFn } from '.';\r\nimport { snippedTagContentAttribute } from '../lib/snipTagContent';\r\n\r\n/**\r\n * Determines whether or not given node\r\n * is the root of the Svelte AST.\r\n */\r\nexport function isASTNode(n: any): n is ASTNode {\r\n    return n && n.__isRoot;\r\n}\r\n\r\nexport function isPreTagContent(path: FastPath): boolean {\r\n    const stack = path.stack as Node[];\r\n\r\n    return stack.some(\r\n        (node) =>\r\n            (node.type === 'Element' && node.name.toLowerCase() === 'pre') ||\r\n            (node.type === 'Attribute' && !formattableAttributes.includes(node.name)),\r\n    );\r\n}\r\n\r\nexport function flatten<T>(arrays: T[][]): T[] {\r\n    return ([] as T[]).concat.apply([], arrays);\r\n}\r\n\r\nexport function findLastIndex<T>(isMatch: (item: T, idx: number) => boolean, items: T[]) {\r\n    for (let i = items.length - 1; i >= 0; i--) {\r\n        if (isMatch(items[i], i)) {\r\n            return i;\r\n        }\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\nexport function replaceEndOfLineWith(text: string, replacement: Doc) {\r\n    const parts: Doc[] = [];\r\n    for (const part of text.split('\\n')) {\r\n        if (parts.length > 0) {\r\n            parts.push(replacement);\r\n        }\r\n        if (part.endsWith('\\r')) {\r\n            parts.push(part.slice(0, -1));\r\n        } else {\r\n            parts.push(part);\r\n        }\r\n    }\r\n    return parts;\r\n}\r\n\r\nexport function groupConcat(contents: doc.builders.Doc[]): doc.builders.Doc {\r\n    const { concat, group } = doc.builders;\r\n    return group(concat(contents));\r\n}\r\n\r\nexport function getAttributeLine(\r\n    node:\r\n        | ElementNode\r\n        | InlineComponentNode\r\n        | SlotNode\r\n        | WindowNode\r\n        | HeadNode\r\n        | TitleNode\r\n        | StyleNode\r\n        | ScriptNode\r\n        | BodyNode\r\n        | DocumentNode\r\n        | OptionsNode\r\n        | SlotTemplateNode,\r\n    options: ParserOptions,\r\n) {\r\n    const { hardline, line } = doc.builders;\r\n    const hasThisBinding =\r\n        (node.type === 'InlineComponent' && !!node.expression) ||\r\n        (node.type === 'Element' && !!node.tag);\r\n\r\n    const attributes = (node.attributes as Array<AttributeNode>).filter(\r\n        (attribute) => attribute.name !== snippedTagContentAttribute,\r\n    );\r\n    return options.singleAttributePerLine &&\r\n        (attributes.length > 1 || (attributes.length && hasThisBinding))\r\n        ? hardline\r\n        : line;\r\n}\r\n\r\nexport function printWithPrependedAttributeLine(\r\n    node:\r\n        | ElementNode\r\n        | InlineComponentNode\r\n        | SlotNode\r\n        | WindowNode\r\n        | HeadNode\r\n        | TitleNode\r\n        | StyleNode\r\n        | ScriptNode\r\n        | BodyNode\r\n        | DocumentNode\r\n        | OptionsNode\r\n        | SlotTemplateNode,\r\n    options: ParserOptions,\r\n    print: PrintFn,\r\n): PrintFn {\r\n    return (path) =>\r\n        path.getNode().name !== snippedTagContentAttribute\r\n            ? doc.builders.concat([getAttributeLine(node, options), path.call(print)])\r\n            : '';\r\n}\r\n","import { Doc, doc } from 'prettier';\r\nimport { findLastIndex } from './helpers';\r\n\r\n/**\r\n * Check if doc is a hardline.\r\n * We can't just rely on a simple equality check because the doc could be created with another\r\n * runtime version of prettier than what we import, making a reference check fail.\r\n */\r\nexport function isHardline(docToCheck: Doc): boolean {\r\n    return docToCheck === doc.builders.hardline || deepEqual(docToCheck, doc.builders.hardline);\r\n}\r\n\r\n/**\r\n * Simple deep equal function which suits our needs. Only works properly on POJOs without cyclic deps.\r\n */\r\nfunction deepEqual(x: any, y: any): boolean {\r\n    if (x === y) {\r\n        return true;\r\n    } else if (typeof x == 'object' && x != null && typeof y == 'object' && y != null) {\r\n        if (Object.keys(x).length != Object.keys(y).length) return false;\r\n\r\n        for (var prop in x) {\r\n            if (y.hasOwnProperty(prop)) {\r\n                if (!deepEqual(x[prop], y[prop])) return false;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction isDocCommand(doc: Doc): doc is doc.builders.DocCommand {\r\n    return typeof doc === 'object' && doc !== null;\r\n}\r\n\r\nexport function isLine(docToCheck: Doc): boolean {\r\n    return (\r\n        isHardline(docToCheck) ||\r\n        (isDocCommand(docToCheck) && docToCheck.type === 'line') ||\r\n        (isDocCommand(docToCheck) &&\r\n            docToCheck.type === 'concat' &&\r\n            docToCheck.parts.every(isLine)) ||\r\n        // Since Prettier 2.3.0, concats are represented as flat arrays\r\n        (Array.isArray(docToCheck) && docToCheck.every(isLine))\r\n    );\r\n}\r\n\r\n/**\r\n * Check if the doc is empty, i.e. consists of nothing more than empty strings (possibly nested).\r\n */\r\nexport function isEmptyDoc(doc: Doc): boolean {\r\n    if (typeof doc === 'string') {\r\n        return doc.length === 0;\r\n    }\r\n\r\n    if (isDocCommand(doc) && doc.type === 'line') {\r\n        return !doc.keepIfLonely;\r\n    }\r\n\r\n    // Since Prettier 2.3.0, concats are represented as flat arrays\r\n    if (Array.isArray(doc)) {\r\n        return doc.length === 0;\r\n    }\r\n\r\n    const { contents } = doc as { contents?: Doc };\r\n\r\n    if (contents) {\r\n        return isEmptyDoc(contents);\r\n    }\r\n\r\n    const { parts } = doc as { parts?: Doc[] };\r\n\r\n    if (parts) {\r\n        return isEmptyGroup(parts);\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nexport function isEmptyGroup(group: Doc[]): boolean {\r\n    return !group.find((doc) => !isEmptyDoc(doc));\r\n}\r\n\r\n/**\r\n * Trims both leading and trailing nodes matching `isWhitespace` independent of nesting level\r\n * (though all trimmed adjacent nodes need to be a the same level). Modifies the `docs` array.\r\n */\r\nexport function trim(docs: Doc[], isWhitespace: (doc: Doc) => boolean): Doc[] {\r\n    trimLeft(docs, isWhitespace);\r\n    trimRight(docs, isWhitespace);\r\n\r\n    return docs;\r\n}\r\n\r\n/**\r\n * Trims the leading nodes matching `isWhitespace` independent of nesting level (though all nodes need to be a the same level).\r\n * If there are empty docs before the first whitespace, they are removed, too.\r\n */\r\nexport function trimLeft(group: Doc[], isWhitespace: (doc: Doc) => boolean): void {\r\n    let firstNonWhitespace = group.findIndex((doc) => !isEmptyDoc(doc) && !isWhitespace(doc));\r\n\r\n    if (firstNonWhitespace < 0 && group.length) {\r\n        firstNonWhitespace = group.length;\r\n    }\r\n\r\n    if (firstNonWhitespace > 0) {\r\n        const removed = group.splice(0, firstNonWhitespace);\r\n        if (removed.every(isEmptyDoc)) {\r\n            return trimLeft(group, isWhitespace);\r\n        }\r\n    } else {\r\n        const parts = getParts(group[0]);\r\n\r\n        if (parts) {\r\n            return trimLeft(parts, isWhitespace);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Trims the trailing nodes matching `isWhitespace` independent of nesting level (though all nodes need to be a the same level).\r\n * If there are empty docs after the last whitespace, they are removed, too.\r\n */\r\nexport function trimRight(group: Doc[], isWhitespace: (doc: Doc) => boolean): void {\r\n    let lastNonWhitespace = group.length\r\n        ? findLastIndex((doc) => !isEmptyDoc(doc) && !isWhitespace(doc), group)\r\n        : 0;\r\n\r\n    if (lastNonWhitespace < group.length - 1) {\r\n        const removed = group.splice(lastNonWhitespace + 1);\r\n        if (removed.every(isEmptyDoc)) {\r\n            return trimRight(group, isWhitespace);\r\n        }\r\n    } else {\r\n        const parts = getParts(group[group.length - 1]);\r\n\r\n        if (parts) {\r\n            return trimRight(parts, isWhitespace);\r\n        }\r\n    }\r\n}\r\n\r\nfunction getParts(doc: Doc): Doc[] | undefined {\r\n    if (typeof doc === 'object') {\r\n        // Since Prettier 2.3.0, concats are represented as flat arrays\r\n        if (Array.isArray(doc)) {\r\n            return doc;\r\n        }\r\n        if (doc.type === 'fill' || doc.type === 'concat') {\r\n            return doc.parts;\r\n        }\r\n        if (doc.type === 'group') {\r\n            return getParts(doc.contents);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * `(foo = bar)` => `foo = bar`\r\n */\r\nexport function removeParentheses(doc: Doc): Doc {\r\n    return trim([doc], (_doc: Doc) => _doc === '(' || _doc === ')')[0];\r\n}\r\n","import {\r\n    Node,\r\n    ElementNode,\r\n    TextNode,\r\n    AttributeNode,\r\n    MustacheTagNode,\r\n    AttributeShorthandNode,\r\n    HeadNode,\r\n    InlineComponentNode,\r\n    SlotNode,\r\n    TitleNode,\r\n    WindowNode,\r\n    IfBlockNode,\r\n    AwaitBlockNode,\r\n    CatchBlockNode,\r\n    EachBlockNode,\r\n    ElseBlockNode,\r\n    KeyBlockNode,\r\n    PendingBlockNode,\r\n    ThenBlockNode,\r\n    CommentNode,\r\n    SlotTemplateNode,\r\n    StyleDirectiveNode,\r\n} from './nodes';\r\nimport { blockElements, TagName } from '../lib/elements';\r\nimport { FastPath, ParserOptions } from 'prettier';\r\nimport { findLastIndex, isASTNode, isPreTagContent } from './helpers';\r\nimport { isBracketSameLine } from '../options';\r\n\r\nconst unsupportedLanguages = ['coffee', 'coffeescript', 'styl', 'stylus', 'sass'];\r\n\r\nexport function isInlineElement(path: FastPath, options: ParserOptions, node: Node) {\r\n    return (\r\n        node && node.type === 'Element' && !isBlockElement(node, options) && !isPreTagContent(path)\r\n    );\r\n}\r\n\r\nexport function isBlockElement(node: Node, options: ParserOptions): node is ElementNode {\r\n    return (\r\n        node &&\r\n        node.type === 'Element' &&\r\n        options.htmlWhitespaceSensitivity !== 'strict' &&\r\n        (options.htmlWhitespaceSensitivity === 'ignore' ||\r\n            blockElements.includes(node.name as TagName))\r\n    );\r\n}\r\n\r\nexport function isSvelteBlock(\r\n    node: Node,\r\n): node is\r\n    | IfBlockNode\r\n    | AwaitBlockNode\r\n    | CatchBlockNode\r\n    | EachBlockNode\r\n    | ElseBlockNode\r\n    | KeyBlockNode\r\n    | PendingBlockNode\r\n    | ThenBlockNode {\r\n    return [\r\n        'IfBlock',\r\n        'AwaitBlock',\r\n        'CatchBlock',\r\n        'EachBlock',\r\n        'ElseBlock',\r\n        'KeyBlock',\r\n        'PendingBlock',\r\n        'ThenBlock',\r\n    ].includes(node.type);\r\n}\r\n\r\nexport function isNodeWithChildren(node: Node): node is Node & { children: Node[] } {\r\n    return (node as any).children;\r\n}\r\n\r\nexport function getChildren(node: Node): Node[] {\r\n    return isNodeWithChildren(node) ? node.children : [];\r\n}\r\n\r\n/**\r\n * Returns siblings, that is, the children of the parent.\r\n */\r\nexport function getSiblings(path: FastPath): Node[] {\r\n    let parent: Node = path.getParentNode();\r\n\r\n    if (isASTNode(parent)) {\r\n        parent = parent.html;\r\n    }\r\n\r\n    return getChildren(parent);\r\n}\r\n\r\n/**\r\n * Returns the previous sibling node.\r\n */\r\nexport function getPreviousNode(path: FastPath): Node | undefined {\r\n    const node: Node = path.getNode();\r\n    return getSiblings(path).find((child) => child.end === node.start);\r\n}\r\n\r\n/**\r\n * Returns the next sibling node.\r\n */\r\nexport function getNextNode(path: FastPath, node: Node = path.getNode()): Node | undefined {\r\n    return getSiblings(path).find((child) => child.start === node.end);\r\n}\r\n\r\n/**\r\n * Returns the comment that is above the current node.\r\n */\r\nexport function getLeadingComment(path: FastPath): CommentNode | undefined {\r\n    const siblings = getSiblings(path);\r\n\r\n    let node: Node = path.getNode();\r\n    let prev: Node | undefined = siblings.find((child) => child.end === node.start);\r\n    while (prev) {\r\n        if (\r\n            prev.type === 'Comment' &&\r\n            !isIgnoreStartDirective(prev) &&\r\n            !isIgnoreEndDirective(prev)\r\n        ) {\r\n            return prev;\r\n        } else if (isEmptyTextNode(prev)) {\r\n            node = prev;\r\n            prev = siblings.find((child) => child.end === node.start);\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Did there use to be any embedded object (that has been snipped out of the AST to be moved)\r\n * at the specified position?\r\n */\r\nexport function doesEmbedStartAfterNode(node: Node, path: FastPath, siblings = getSiblings(path)) {\r\n    // If node is not at the top level of html, an embed cannot start after it,\r\n    // because embeds are only at the top level\r\n    if (!isNodeTopLevelHTML(node, path)) {\r\n        return false;\r\n    }\r\n\r\n    const position = node.end;\r\n    const root = path.stack[0];\r\n\r\n    const embeds = [root.css, root.html, root.instance, root.js, root.module] as Node[];\r\n\r\n    const nextNode = siblings[siblings.indexOf(node) + 1];\r\n    return embeds.find((n) => n && n.start >= position && (!nextNode || n.end <= nextNode.start));\r\n}\r\n\r\nexport function isNodeTopLevelHTML(node: Node, path: FastPath): boolean {\r\n    const root = path.stack[0];\r\n    return !!root.html && !!root.html.children && root.html.children.includes(node);\r\n}\r\n\r\nexport function isEmptyTextNode(node: Node | undefined): node is TextNode {\r\n    return !!node && node.type === 'Text' && getUnencodedText(node).trim() === '';\r\n}\r\n\r\nexport function isIgnoreDirective(node: Node | undefined | null): boolean {\r\n    return !!node && node.type === 'Comment' && node.data.trim() === 'prettier-ignore';\r\n}\r\n\r\nexport function isIgnoreStartDirective(node: Node | undefined | null): boolean {\r\n    return !!node && node.type === 'Comment' && node.data.trim() === 'prettier-ignore-start';\r\n}\r\n\r\nexport function isIgnoreEndDirective(node: Node | undefined | null): boolean {\r\n    return !!node && node.type === 'Comment' && node.data.trim() === 'prettier-ignore-end';\r\n}\r\n\r\nexport function printRaw(\r\n    node:\r\n        | ElementNode\r\n        | InlineComponentNode\r\n        | SlotNode\r\n        | WindowNode\r\n        | HeadNode\r\n        | TitleNode\r\n        | SlotTemplateNode,\r\n    originalText: string,\r\n    stripLeadingAndTrailingNewline: boolean = false,\r\n): string {\r\n    if (node.children.length === 0) {\r\n        return '';\r\n    }\r\n\r\n    const firstChild = node.children[0];\r\n    const lastChild = node.children[node.children.length - 1];\r\n\r\n    let raw = originalText.substring(firstChild.start, lastChild.end);\r\n\r\n    if (!stripLeadingAndTrailingNewline) {\r\n        return raw;\r\n    }\r\n\r\n    if (startsWithLinebreak(raw)) {\r\n        raw = raw.substring(raw.indexOf('\\n') + 1);\r\n    }\r\n    if (endsWithLinebreak(raw)) {\r\n        raw = raw.substring(0, raw.lastIndexOf('\\n'));\r\n        if (raw.charAt(raw.length - 1) === '\\r') {\r\n            raw = raw.substring(0, raw.length - 1);\r\n        }\r\n    }\r\n\r\n    return raw;\r\n}\r\n\r\nfunction isTextNode(node: Node): node is TextNode {\r\n    return node.type === 'Text';\r\n}\r\n\r\nfunction getAttributeValue(attributeName: string, node: Node) {\r\n    const attributes = (node as ElementNode)['attributes'] as AttributeNode[];\r\n\r\n    const langAttribute = attributes.find(\r\n        (attribute) => attribute.name === attributeName,\r\n    ) as AttributeNode | null;\r\n\r\n    return langAttribute && langAttribute.value;\r\n}\r\n\r\nexport function getAttributeTextValue(attributeName: string, node: Node): string | null {\r\n    const value = getAttributeValue(attributeName, node);\r\n\r\n    if (value != null && typeof value === 'object') {\r\n        const textValue = value.find(isTextNode);\r\n\r\n        if (textValue) {\r\n            return textValue.data;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nfunction getLangAttribute(node: Node): string | null {\r\n    const value = getAttributeTextValue('lang', node) || getAttributeTextValue('type', node);\r\n\r\n    if (value != null) {\r\n        return value.replace(/^text\\//, '');\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * Checks whether the node contains a `lang` or `type` attribute with a value corresponding to\r\n * a language we cannot format. This might for example be `<template lang=\"pug\">`.\r\n * If the node does not contain a `lang` attribute, the result is true.\r\n */\r\nexport function isNodeSupportedLanguage(node: Node) {\r\n    const lang = getLangAttribute(node);\r\n\r\n    return !(lang && unsupportedLanguages.includes(lang));\r\n}\r\n\r\n/**\r\n * Checks whether the node contains a `lang` or `type` attribute which indicates that\r\n * the script contents are written in TypeScript. Note that the absence of the tag\r\n * does not mean it's not TypeScript, because the user could have set the default\r\n * to TypeScript in his settings.\r\n */\r\nexport function isTypeScript(node: Node) {\r\n    const lang = getLangAttribute(node) || '';\r\n    return ['typescript', 'ts'].includes(lang);\r\n}\r\n\r\nexport function isPugTemplate(node: Node): boolean {\r\n    return node.type === 'Element' && node.name === 'template' && getLangAttribute(node) === 'pug';\r\n}\r\n\r\nexport function isLoneMustacheTag(node: true | Node[]): node is [MustacheTagNode] {\r\n    return node !== true && node.length === 1 && node[0].type === 'MustacheTag';\r\n}\r\n\r\nexport function isAttributeShorthand(node: true | Node[]): node is [AttributeShorthandNode] {\r\n    return node !== true && node.length === 1 && node[0].type === 'AttributeShorthand';\r\n}\r\n\r\n/**\r\n * True if node is of type `{a}` or `a={a}`\r\n */\r\nexport function isOrCanBeConvertedToShorthand(node: AttributeNode | StyleDirectiveNode): boolean {\r\n    if (isAttributeShorthand(node.value)) {\r\n        return true;\r\n    }\r\n\r\n    if (isLoneMustacheTag(node.value)) {\r\n        const expression = node.value[0].expression;\r\n        return expression.type === 'Identifier' && expression.name === node.name;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nexport function getUnencodedText(node: TextNode) {\r\n    // `raw` will contain HTML entities in unencoded form\r\n    return node.raw || node.data;\r\n}\r\n\r\nexport function isTextNodeStartingWithLinebreak(node: Node, nrLines = 1): node is TextNode {\r\n    return node.type === 'Text' && startsWithLinebreak(getUnencodedText(node), nrLines);\r\n}\r\n\r\nexport function startsWithLinebreak(text: string, nrLines = 1): boolean {\r\n    return new RegExp(`^([\\\\t\\\\f\\\\r ]*\\\\n){${nrLines}}`).test(text);\r\n}\r\n\r\nexport function isTextNodeEndingWithLinebreak(node: Node, nrLines = 1): node is TextNode {\r\n    return node.type === 'Text' && endsWithLinebreak(getUnencodedText(node), nrLines);\r\n}\r\n\r\nexport function endsWithLinebreak(text: string, nrLines = 1): boolean {\r\n    return new RegExp(`(\\\\n[\\\\t\\\\f\\\\r ]*){${nrLines}}$`).test(text);\r\n}\r\n\r\nexport function isTextNodeStartingWithWhitespace(node: Node): node is TextNode {\r\n    return node.type === 'Text' && /^\\s/.test(getUnencodedText(node));\r\n}\r\n\r\nexport function isTextNodeEndingWithWhitespace(node: Node): node is TextNode {\r\n    return node.type === 'Text' && /\\s$/.test(getUnencodedText(node));\r\n}\r\n\r\nexport function trimTextNodeRight(node: TextNode): void {\r\n    node.raw = node.raw && node.raw.trimRight();\r\n    node.data = node.data && node.data.trimRight();\r\n}\r\n\r\nexport function trimTextNodeLeft(node: TextNode): void {\r\n    node.raw = node.raw && node.raw.trimLeft();\r\n    node.data = node.data && node.data.trimLeft();\r\n}\r\n\r\n/**\r\n * Remove all leading whitespace up until the first non-empty text node,\r\n * and all trailing whitespace from the last non-empty text node onwards.\r\n */\r\nexport function trimChildren(children: Node[], path: FastPath): void {\r\n    let firstNonEmptyNode = children.findIndex(\r\n        (n) => !isEmptyTextNode(n) && !doesEmbedStartAfterNode(n, path),\r\n    );\r\n    firstNonEmptyNode = firstNonEmptyNode === -1 ? children.length - 1 : firstNonEmptyNode;\r\n\r\n    let lastNonEmptyNode = findLastIndex((n, idx) => {\r\n        // Last node is ok to end at the start of an embedded region,\r\n        // if it's not a comment (which should stick to the region)\r\n        return (\r\n            !isEmptyTextNode(n) &&\r\n            ((idx === children.length - 1 && n.type !== 'Comment') ||\r\n                !doesEmbedStartAfterNode(n, path))\r\n        );\r\n    }, children);\r\n    lastNonEmptyNode = lastNonEmptyNode === -1 ? 0 : lastNonEmptyNode;\r\n\r\n    for (let i = 0; i <= firstNonEmptyNode; i++) {\r\n        const n = children[i];\r\n        if (n.type === 'Text') {\r\n            trimTextNodeLeft(n);\r\n        }\r\n    }\r\n\r\n    for (let i = children.length - 1; i >= lastNonEmptyNode; i--) {\r\n        const n = children[i];\r\n        if (n.type === 'Text') {\r\n            trimTextNodeRight(n);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Check if given node's start tag should hug its first child. This is the case for inline elements when there's\r\n * no whitespace between the `>` and the first child.\r\n */\r\nexport function shouldHugStart(\r\n    node: Node,\r\n    isSupportedLanguage: boolean,\r\n    options: ParserOptions,\r\n): boolean {\r\n    if (!isSupportedLanguage) {\r\n        return true;\r\n    }\r\n\r\n    if (isBlockElement(node, options)) {\r\n        return false;\r\n    }\r\n\r\n    if (!isNodeWithChildren(node)) {\r\n        return false;\r\n    }\r\n\r\n    const children: Node[] = node.children;\r\n    if (children.length === 0) {\r\n        return true;\r\n    }\r\n\r\n    if (options.htmlWhitespaceSensitivity === 'ignore') {\r\n        return false;\r\n    }\r\n\r\n    const firstChild = children[0];\r\n    return !isTextNodeStartingWithWhitespace(firstChild);\r\n}\r\n\r\n/**\r\n * Check if given node's end tag should hug its last child. This is the case for inline elements when there's\r\n * no whitespace between the last child and the `</`.\r\n */\r\nexport function shouldHugEnd(\r\n    node: Node,\r\n    isSupportedLanguage: boolean,\r\n    options: ParserOptions,\r\n): boolean {\r\n    if (!isSupportedLanguage) {\r\n        return true;\r\n    }\r\n\r\n    if (isBlockElement(node, options)) {\r\n        return false;\r\n    }\r\n\r\n    if (!isNodeWithChildren(node)) {\r\n        return false;\r\n    }\r\n\r\n    const children: Node[] = node.children;\r\n    if (children.length === 0) {\r\n        return true;\r\n    }\r\n\r\n    if (options.htmlWhitespaceSensitivity === 'ignore') {\r\n        return false;\r\n    }\r\n\r\n    const lastChild = children[children.length - 1];\r\n    return !isTextNodeEndingWithWhitespace(lastChild);\r\n}\r\n\r\n/**\r\n * Check for a svelte block if there's whitespace at the start and if it's a space or a line.\r\n */\r\nexport function checkWhitespaceAtStartOfSvelteBlock(\r\n    node: Node,\r\n    options: ParserOptions,\r\n): 'none' | 'space' | 'line' {\r\n    if (!isSvelteBlock(node) || !isNodeWithChildren(node)) {\r\n        return 'none';\r\n    }\r\n\r\n    const children: Node[] = node.children;\r\n    if (children.length === 0) {\r\n        return 'none';\r\n    }\r\n\r\n    const firstChild = children[0];\r\n\r\n    if (isTextNodeStartingWithLinebreak(firstChild)) {\r\n        return 'line';\r\n    } else if (isTextNodeStartingWithWhitespace(firstChild)) {\r\n        return 'space';\r\n    }\r\n\r\n    // This extra check is necessary because the Svelte AST might swallow whitespace between\r\n    // the block's starting end and its first child.\r\n    const parentOpeningEnd = options.originalText.lastIndexOf('}', firstChild.start);\r\n    if (parentOpeningEnd > 0 && firstChild.start > parentOpeningEnd + 1) {\r\n        const textBetween = options.originalText.substring(parentOpeningEnd + 1, firstChild.start);\r\n        if (textBetween.trim() === '') {\r\n            return startsWithLinebreak(textBetween) ? 'line' : 'space';\r\n        }\r\n    }\r\n\r\n    return 'none';\r\n}\r\n\r\n/**\r\n * Check for a svelte block if there's whitespace at the end and if it's a space or a line.\r\n */\r\nexport function checkWhitespaceAtEndOfSvelteBlock(\r\n    node: Node,\r\n    options: ParserOptions,\r\n): 'none' | 'space' | 'line' {\r\n    if (!isSvelteBlock(node) || !isNodeWithChildren(node)) {\r\n        return 'none';\r\n    }\r\n\r\n    const children: Node[] = node.children;\r\n    if (children.length === 0) {\r\n        return 'none';\r\n    }\r\n\r\n    const lastChild = children[children.length - 1];\r\n    if (isTextNodeEndingWithLinebreak(lastChild)) {\r\n        return 'line';\r\n    } else if (isTextNodeEndingWithWhitespace(lastChild)) {\r\n        return 'space';\r\n    }\r\n\r\n    // This extra check is necessary because the Svelte AST might swallow whitespace between\r\n    // the last child and the block's ending start.\r\n    const parentClosingStart = options.originalText.indexOf('{', lastChild.end);\r\n    if (parentClosingStart > 0 && lastChild.end < parentClosingStart) {\r\n        const textBetween = options.originalText.substring(lastChild.end, parentClosingStart);\r\n        if (textBetween.trim() === '') {\r\n            return endsWithLinebreak(textBetween) ? 'line' : 'space';\r\n        }\r\n    }\r\n\r\n    return 'none';\r\n}\r\n\r\nexport function isInsideQuotedAttribute(path: FastPath, options: ParserOptions): boolean {\r\n    const stack = path.stack as Node[];\r\n\r\n    return stack.some(\r\n        (node) =>\r\n            node.type === 'Attribute' &&\r\n            (!isLoneMustacheTag(node.value) || options.svelteStrictMode),\r\n    );\r\n}\r\n\r\n/**\r\n * Returns true if the softline between `</tagName` and `>` can be omitted.\r\n */\r\nexport function canOmitSoftlineBeforeClosingTag(\r\n    node: Node,\r\n    path: FastPath,\r\n    options: ParserOptions,\r\n): boolean {\r\n    return (\r\n        isBracketSameLine(options) &&\r\n        (!hugsStartOfNextNode(node, options) || isLastChildWithinParentBlockElement(path, options))\r\n    );\r\n}\r\n\r\n/**\r\n * Return true if given node does not hug the next node, meaning there's whitespace\r\n * or the end of the doc afterwards.\r\n */\r\nfunction hugsStartOfNextNode(node: Node, options: ParserOptions): boolean {\r\n    if (node.end === options.originalText.length) {\r\n        // end of document\r\n        return false;\r\n    }\r\n\r\n    return !options.originalText.substring(node.end).match(/^\\s/);\r\n}\r\n\r\nfunction isLastChildWithinParentBlockElement(path: FastPath, options: ParserOptions): boolean {\r\n    const parent = path.getParentNode() as Node | undefined;\r\n    if (!parent || !isBlockElement(parent, options)) {\r\n        return false;\r\n    }\r\n\r\n    const children = getChildren(parent);\r\n    const lastChild = children[children.length - 1];\r\n    return lastChild === path.getNode();\r\n}\r\n","import { Doc, doc, FastPath, ParserOptions } from 'prettier';\r\nimport { formattableAttributes, selfClosingTags } from '../lib/elements';\r\nimport { extractAttributes } from '../lib/extractAttributes';\r\nimport { getText } from '../lib/getText';\r\nimport { hasSnippedContent, unsnipContent } from '../lib/snipTagContent';\r\nimport { isBracketSameLine, parseSortOrder, SortOrderPart } from '../options';\r\nimport { isEmptyDoc, isLine, trim, trimRight } from './doc-helpers';\r\nimport {\r\n    flatten,\r\n    getAttributeLine,\r\n    groupConcat,\r\n    isASTNode,\r\n    isPreTagContent,\r\n    printWithPrependedAttributeLine,\r\n    replaceEndOfLineWith,\r\n} from './helpers';\r\nimport {\r\n    checkWhitespaceAtEndOfSvelteBlock,\r\n    checkWhitespaceAtStartOfSvelteBlock,\r\n    doesEmbedStartAfterNode,\r\n    endsWithLinebreak,\r\n    getUnencodedText,\r\n    isBlockElement,\r\n    isEmptyTextNode,\r\n    isIgnoreDirective,\r\n    isInlineElement,\r\n    isInsideQuotedAttribute,\r\n    isLoneMustacheTag,\r\n    isNodeSupportedLanguage,\r\n    isOrCanBeConvertedToShorthand,\r\n    isTextNodeEndingWithLinebreak,\r\n    isTextNodeEndingWithWhitespace,\r\n    isTextNodeStartingWithLinebreak,\r\n    isTextNodeStartingWithWhitespace,\r\n    printRaw,\r\n    shouldHugEnd,\r\n    shouldHugStart,\r\n    startsWithLinebreak,\r\n    trimChildren,\r\n    trimTextNodeLeft,\r\n    trimTextNodeRight,\r\n    canOmitSoftlineBeforeClosingTag,\r\n    getNextNode,\r\n    isIgnoreStartDirective,\r\n    isIgnoreEndDirective,\r\n    isNodeTopLevelHTML,\r\n    getChildren,\r\n} from './node-helpers';\r\nimport {\r\n    ASTNode,\r\n    AttributeNode,\r\n    CommentInfo,\r\n    CommentNode,\r\n    IfBlockNode,\r\n    Node,\r\n    OptionsNode,\r\n    StyleDirectiveNode,\r\n    TextNode,\r\n} from './nodes';\r\n\r\nconst {\r\n    concat,\r\n    join,\r\n    line,\r\n    group,\r\n    indent,\r\n    dedent,\r\n    softline,\r\n    hardline,\r\n    fill,\r\n    breakParent,\r\n    literalline,\r\n} = doc.builders;\r\n\r\nexport type PrintFn = (path: FastPath) => Doc;\r\n\r\ndeclare module 'prettier' {\r\n    export namespace doc {\r\n        namespace builders {\r\n            interface Line {\r\n                keepIfLonely?: boolean;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport function hasPragma(text: string) {\r\n    return /^\\s*<!--\\s*@(format|prettier)\\W/.test(text);\r\n}\r\n\r\nlet ignoreNext = false;\r\nlet ignoreRange = false;\r\nlet svelteOptionsDoc: Doc | undefined;\r\n\r\nexport function print(path: FastPath, options: ParserOptions, print: PrintFn): Doc {\r\n    const bracketSameLine = isBracketSameLine(options);\r\n\r\n    const n = path.getValue();\r\n    if (!n) {\r\n        return '';\r\n    }\r\n\r\n    if (isASTNode(n)) {\r\n        assignCommentsToNodes(n);\r\n        return printTopLevelParts(n, options, path, print);\r\n    }\r\n\r\n    const [open, close] = options.svelteStrictMode ? ['\"{', '}\"'] : ['{', '}'];\r\n    const printJsExpression = () => [\r\n        open,\r\n        printJS(path, print, options.svelteStrictMode, false, false, 'expression'),\r\n        close,\r\n    ];\r\n    const node = n as Node;\r\n\r\n    if (\r\n        (ignoreNext || (ignoreRange && !isIgnoreEndDirective(node))) &&\r\n        (node.type !== 'Text' || !isEmptyTextNode(node))\r\n    ) {\r\n        if (ignoreNext) {\r\n            ignoreNext = false;\r\n        }\r\n        return concat(\r\n            flatten(\r\n                options.originalText\r\n                    .slice(options.locStart(node), options.locEnd(node))\r\n                    .split('\\n')\r\n                    .map((o, i) => (i == 0 ? [o] : [literalline, o])),\r\n            ),\r\n        );\r\n    }\r\n\r\n    switch (node.type) {\r\n        case 'Fragment':\r\n            const children = node.children;\r\n\r\n            if (children.length === 0 || children.every(isEmptyTextNode)) {\r\n                return '';\r\n            }\r\n            if (!isPreTagContent(path)) {\r\n                trimChildren(node.children, path);\r\n                const output = trim(\r\n                    [printChildren(path, print, options)],\r\n                    (n) =>\r\n                        isLine(n) ||\r\n                        (typeof n === 'string' && n.trim() === '') ||\r\n                        // Because printChildren may append this at the end and\r\n                        // may hide other lines before it\r\n                        n === breakParent,\r\n                );\r\n                if (output.every((doc) => isEmptyDoc(doc))) {\r\n                    return '';\r\n                }\r\n                return groupConcat([...output, hardline]);\r\n            } else {\r\n                return groupConcat(path.map(print, 'children'));\r\n            }\r\n        case 'Text':\r\n            if (!isPreTagContent(path)) {\r\n                if (isEmptyTextNode(node)) {\r\n                    const hasWhiteSpace =\r\n                        getUnencodedText(node).trim().length < getUnencodedText(node).length;\r\n                    const hasOneOrMoreNewlines = /\\n/.test(getUnencodedText(node));\r\n                    const hasTwoOrMoreNewlines = /\\n\\r?\\s*\\n\\r?/.test(getUnencodedText(node));\r\n                    if (hasTwoOrMoreNewlines) {\r\n                        return concat([hardline, hardline]);\r\n                    }\r\n                    if (hasOneOrMoreNewlines) {\r\n                        return hardline;\r\n                    }\r\n                    if (hasWhiteSpace) {\r\n                        return line;\r\n                    }\r\n                    return '';\r\n                }\r\n\r\n                /**\r\n                 * For non-empty text nodes each sequence of non-whitespace characters (effectively,\r\n                 * each \"word\") is joined by a single `line`, which will be rendered as a single space\r\n                 * until this node's current line is out of room, at which `fill` will break at the\r\n                 * most convenient instance of `line`.\r\n                 */\r\n                return fill(splitTextToDocs(node));\r\n            } else {\r\n                let rawText = getUnencodedText(node);\r\n                const parent = path.getParentNode();\r\n                if (parent.type === 'Attribute') {\r\n                    // Direct child of attribute value -> add literallines at end of lines\r\n                    // so that other things don't break in unexpected places\r\n                    if (parent.name === 'class' && path.getParentNode(1).type === 'Element') {\r\n                        // Special treatment for class attribute on html elements. Prettier\r\n                        // will force everything into one line, we deviate from that and preserve lines.\r\n                        rawText = rawText.replace(\r\n                            /([^ \\t\\n])(([ \\t]+$)|([ \\t]+(\\r?\\n))|[ \\t]+)/g,\r\n                            // Remove trailing whitespace in lines with non-whitespace characters\r\n                            // except at the end of the string\r\n                            (\r\n                                match,\r\n                                characterBeforeWhitespace,\r\n                                _,\r\n                                isEndOfString,\r\n                                isEndOfLine,\r\n                                endOfLine,\r\n                            ) =>\r\n                                isEndOfString\r\n                                    ? match\r\n                                    : characterBeforeWhitespace + (isEndOfLine ? endOfLine : ' '),\r\n                        );\r\n                        // Shrink trailing whitespace in case it's followed by a mustache tag\r\n                        // and remove it completely if it's at the end of the string, but not\r\n                        // if it's on its own line\r\n                        rawText = rawText.replace(\r\n                            /([^ \\t\\n])[ \\t]+$/,\r\n                            parent.value.indexOf(node) === parent.value.length - 1 ? '$1' : '$1 ',\r\n                        );\r\n                    }\r\n                    return concat(replaceEndOfLineWith(rawText, literalline));\r\n                }\r\n                return rawText;\r\n            }\r\n        case 'Element':\r\n        case 'InlineComponent':\r\n        case 'Slot':\r\n        case 'SlotTemplate':\r\n        case 'Window':\r\n        case 'Head':\r\n        case 'Title': {\r\n            const isSupportedLanguage = !(\r\n                node.name === 'template' && !isNodeSupportedLanguage(node)\r\n            );\r\n            const isEmpty = node.children.every((child) => isEmptyTextNode(child));\r\n            const isDoctypeTag = node.name.toUpperCase() === '!DOCTYPE';\r\n\r\n            const isSelfClosingTag =\r\n                isEmpty &&\r\n                (!options.svelteStrictMode ||\r\n                    node.type !== 'Element' ||\r\n                    selfClosingTags.indexOf(node.name) !== -1 ||\r\n                    isDoctypeTag);\r\n\r\n            // Order important: print attributes first\r\n            const attributes = path.map(\r\n                printWithPrependedAttributeLine(node, options, print),\r\n                'attributes',\r\n            );\r\n            const attributeLine = getAttributeLine(node, options);\r\n            const possibleThisBinding =\r\n                node.type === 'InlineComponent' && node.expression\r\n                    ? concat([attributeLine, 'this=', ...printJsExpression()])\r\n                    : node.type === 'Element' && node.tag\r\n                    ? concat([\r\n                          attributeLine,\r\n                          'this=',\r\n                          ...(typeof node.tag === 'string'\r\n                              ? [`\"${node.tag}\"`]\r\n                              : [\r\n                                    open,\r\n                                    printJS(\r\n                                        path,\r\n                                        print,\r\n                                        options.svelteStrictMode,\r\n                                        false,\r\n                                        false,\r\n                                        'tag',\r\n                                    ),\r\n                                    close,\r\n                                ]),\r\n                      ])\r\n                    : '';\r\n\r\n            if (isSelfClosingTag) {\r\n                return groupConcat([\r\n                    '<',\r\n                    node.name,\r\n\r\n                    indent(\r\n                        groupConcat([\r\n                            possibleThisBinding,\r\n                            ...attributes,\r\n                            bracketSameLine || isDoctypeTag ? '' : dedent(line),\r\n                        ]),\r\n                    ),\r\n\r\n                    ...[bracketSameLine && !isDoctypeTag ? ' ' : '', `${isDoctypeTag ? '' : '/'}>`],\r\n                ]);\r\n            }\r\n\r\n            const children = node.children;\r\n            const firstChild = children[0];\r\n            const lastChild = children[children.length - 1];\r\n\r\n            // Is a function which is invoked later because printChildren will manipulate child nodes\r\n            // which would wrongfully change the other checks about hugging etc done beforehand\r\n            let body: () => Doc;\r\n\r\n            const hugStart = shouldHugStart(node, isSupportedLanguage, options);\r\n            const hugEnd = shouldHugEnd(node, isSupportedLanguage, options);\r\n\r\n            if (isEmpty) {\r\n                body =\r\n                    isInlineElement(path, options, node) &&\r\n                    node.children.length &&\r\n                    isTextNodeStartingWithWhitespace(node.children[0]) &&\r\n                    !isPreTagContent(path)\r\n                        ? () => line\r\n                        : () => (bracketSameLine ? softline : '');\r\n            } else if (isPreTagContent(path)) {\r\n                body = () => printPre(node, options.originalText, path, print);\r\n            } else if (!isSupportedLanguage) {\r\n                body = () => printRaw(node, options.originalText, true);\r\n            } else if (isInlineElement(path, options, node) && !isPreTagContent(path)) {\r\n                body = () => printChildren(path, print, options);\r\n            } else {\r\n                body = () => printChildren(path, print, options);\r\n            }\r\n\r\n            const openingTag = [\r\n                '<',\r\n                node.name,\r\n\r\n                indent(\r\n                    groupConcat([\r\n                        possibleThisBinding,\r\n                        ...attributes,\r\n                        hugStart\r\n                            ? ''\r\n                            : !bracketSameLine && !isPreTagContent(path)\r\n                            ? dedent(softline)\r\n                            : '',\r\n                    ]),\r\n                ),\r\n            ];\r\n\r\n            if (!isSupportedLanguage && !isEmpty) {\r\n                // Format template tags so that there's a hardline but no indention.\r\n                // That way the `lang=\"X\"` and the closing `>` of the start tag stay in one line\r\n                // which is the 99% use case.\r\n                return groupConcat([\r\n                    ...openingTag,\r\n                    '>',\r\n                    groupConcat([hardline, body(), hardline]),\r\n                    `</${node.name}>`,\r\n                ]);\r\n            }\r\n\r\n            if (hugStart && hugEnd) {\r\n                const huggedContent = concat([\r\n                    softline,\r\n                    groupConcat(['>', body(), `</${node.name}`]),\r\n                ]);\r\n                const omitSoftlineBeforeClosingTag =\r\n                    (isEmpty && !bracketSameLine) ||\r\n                    canOmitSoftlineBeforeClosingTag(node, path, options);\r\n                return groupConcat([\r\n                    ...openingTag,\r\n                    isEmpty ? group(huggedContent) : group(indent(huggedContent)),\r\n                    omitSoftlineBeforeClosingTag ? '' : softline,\r\n                    '>',\r\n                ]);\r\n            }\r\n\r\n            // No hugging of content means it's either a block element and/or there's whitespace at the start/end\r\n            let noHugSeparatorStart: Doc = softline;\r\n            let noHugSeparatorEnd: Doc = softline;\r\n            if (isPreTagContent(path)) {\r\n                noHugSeparatorStart = '';\r\n                noHugSeparatorEnd = '';\r\n            } else {\r\n                let didSetEndSeparator = false;\r\n\r\n                if (!hugStart && firstChild && firstChild.type === 'Text') {\r\n                    if (\r\n                        isTextNodeStartingWithLinebreak(firstChild) &&\r\n                        firstChild !== lastChild &&\r\n                        (!isInlineElement(path, options, node) ||\r\n                            isTextNodeEndingWithWhitespace(lastChild))\r\n                    ) {\r\n                        noHugSeparatorStart = hardline;\r\n                        noHugSeparatorEnd = hardline;\r\n                        didSetEndSeparator = true;\r\n                    } else if (isInlineElement(path, options, node)) {\r\n                        noHugSeparatorStart = line;\r\n                    }\r\n                    trimTextNodeLeft(firstChild);\r\n                }\r\n                if (!hugEnd && lastChild && lastChild.type === 'Text') {\r\n                    if (isInlineElement(path, options, node) && !didSetEndSeparator) {\r\n                        noHugSeparatorEnd = line;\r\n                    }\r\n                    trimTextNodeRight(lastChild);\r\n                }\r\n            }\r\n\r\n            if (hugStart) {\r\n                return groupConcat([\r\n                    ...openingTag,\r\n                    indent(concat([softline, groupConcat(['>', body()])])),\r\n                    noHugSeparatorEnd,\r\n                    `</${node.name}>`,\r\n                ]);\r\n            }\r\n\r\n            if (hugEnd) {\r\n                return groupConcat([\r\n                    ...openingTag,\r\n                    '>',\r\n                    indent(concat([noHugSeparatorStart, groupConcat([body(), `</${node.name}`])])),\r\n                    canOmitSoftlineBeforeClosingTag(node, path, options) ? '' : softline,\r\n                    '>',\r\n                ]);\r\n            }\r\n\r\n            if (isEmpty) {\r\n                return groupConcat([...openingTag, '>', body(), `</${node.name}>`]);\r\n            }\r\n\r\n            return groupConcat([\r\n                ...openingTag,\r\n                '>',\r\n                indent(concat([noHugSeparatorStart, body()])),\r\n                noHugSeparatorEnd,\r\n                `</${node.name}>`,\r\n            ]);\r\n        }\r\n        case 'Options':\r\n            if (options.svelteSortOrder !== 'none') {\r\n                throw new Error('Options tags should have been handled by prepareChildren');\r\n            }\r\n        // else fall through to Body\r\n        case 'Body':\r\n            return groupConcat([\r\n                '<',\r\n                node.name,\r\n                indent(\r\n                    groupConcat([\r\n                        ...path.map(\r\n                            printWithPrependedAttributeLine(node, options, print),\r\n                            'attributes',\r\n                        ),\r\n                        bracketSameLine ? '' : dedent(line),\r\n                    ]),\r\n                ),\r\n                ...[bracketSameLine ? ' ' : '', '/>'],\r\n            ]);\r\n        case 'Document':\r\n            return groupConcat([\r\n                '<',\r\n                node.name,\r\n                indent(\r\n                    groupConcat([\r\n                        ...path.map(\r\n                            printWithPrependedAttributeLine(node, options, print),\r\n                            'attributes',\r\n                        ),\r\n                        bracketSameLine ? '' : dedent(line),\r\n                    ]),\r\n                ),\r\n                ...[bracketSameLine ? ' ' : '', '/>'],\r\n            ]);\r\n        case 'Identifier':\r\n            return node.name;\r\n        case 'AttributeShorthand': {\r\n            return (node.expression as any).name;\r\n        }\r\n        case 'Attribute': {\r\n            if (isOrCanBeConvertedToShorthand(node)) {\r\n                if (options.svelteStrictMode) {\r\n                    return concat([node.name, '=\"{', node.name, '}\"']);\r\n                } else if (options.svelteAllowShorthand) {\r\n                    return concat(['{', node.name, '}']);\r\n                } else {\r\n                    return concat([node.name, '={', node.name, '}']);\r\n                }\r\n            } else {\r\n                if (node.value === true) {\r\n                    return concat([node.name]);\r\n                }\r\n\r\n                const quotes = !isLoneMustacheTag(node.value) || options.svelteStrictMode;\r\n                const attrNodeValue = printAttributeNodeValue(path, print, quotes, node);\r\n                if (quotes) {\r\n                    return concat([node.name, '=', '\"', attrNodeValue, '\"']);\r\n                } else {\r\n                    return concat([node.name, '=', attrNodeValue]);\r\n                }\r\n            }\r\n        }\r\n        case 'MustacheTag':\r\n            return concat([\r\n                '{',\r\n                printJS(\r\n                    path,\r\n                    print,\r\n                    isInsideQuotedAttribute(path, options),\r\n                    false,\r\n                    false,\r\n                    'expression',\r\n                ),\r\n                '}',\r\n            ]);\r\n        case 'IfBlock': {\r\n            const def: Doc[] = [\r\n                '{#if ',\r\n                printSvelteBlockJS(path, print, 'expression'),\r\n                '}',\r\n                printSvelteBlockChildren(path, print, options),\r\n            ];\r\n\r\n            if (node.else) {\r\n                def.push(path.call(print, 'else'));\r\n            }\r\n\r\n            def.push('{/if}');\r\n\r\n            return concat([groupConcat(def), breakParent]);\r\n        }\r\n        case 'ElseBlock': {\r\n            // Else if\r\n            const parent = path.getParentNode() as Node;\r\n\r\n            if (\r\n                node.children.length === 1 &&\r\n                node.children[0].type === 'IfBlock' &&\r\n                parent.type !== 'EachBlock'\r\n            ) {\r\n                const ifNode = node.children[0] as IfBlockNode;\r\n                const def: Doc[] = [\r\n                    '{:else if ',\r\n                    path.map(\r\n                        (ifPath) => printSvelteBlockJS(ifPath, print, 'expression'),\r\n                        'children',\r\n                    )[0],\r\n                    '}',\r\n                    path.map(\r\n                        (ifPath) => printSvelteBlockChildren(ifPath, print, options),\r\n                        'children',\r\n                    )[0],\r\n                ];\r\n\r\n                if (ifNode.else) {\r\n                    def.push(path.map((ifPath) => ifPath.call(print, 'else'), 'children')[0]);\r\n                }\r\n                return concat(def);\r\n            }\r\n\r\n            return concat(['{:else}', printSvelteBlockChildren(path, print, options)]);\r\n        }\r\n        case 'EachBlock': {\r\n            const def: Doc[] = [\r\n                '{#each ',\r\n                printSvelteBlockJS(path, print, 'expression'),\r\n                ' as',\r\n                expandNode(node.context),\r\n            ];\r\n\r\n            if (node.index) {\r\n                def.push(', ', node.index);\r\n            }\r\n\r\n            if (node.key) {\r\n                def.push(' (', printSvelteBlockJS(path, print, 'key'), ')');\r\n            }\r\n\r\n            def.push('}', printSvelteBlockChildren(path, print, options));\r\n\r\n            if (node.else) {\r\n                def.push(path.call(print, 'else'));\r\n            }\r\n\r\n            def.push('{/each}');\r\n\r\n            return concat([groupConcat(def), breakParent]);\r\n        }\r\n        case 'AwaitBlock': {\r\n            const hasPendingBlock = node.pending.children.some((n) => !isEmptyTextNode(n));\r\n            const hasThenBlock = node.then.children.some((n) => !isEmptyTextNode(n));\r\n            const hasCatchBlock = node.catch.children.some((n) => !isEmptyTextNode(n));\r\n\r\n            let block = [];\r\n\r\n            if (!hasPendingBlock && hasThenBlock) {\r\n                block.push(\r\n                    groupConcat([\r\n                        '{#await ',\r\n                        printSvelteBlockJS(path, print, 'expression'),\r\n                        ' then',\r\n                        expandNode(node.value),\r\n                        '}',\r\n                    ]),\r\n                    path.call(print, 'then'),\r\n                );\r\n            } else if (!hasPendingBlock && hasCatchBlock) {\r\n                block.push(\r\n                    groupConcat([\r\n                        '{#await ',\r\n                        printSvelteBlockJS(path, print, 'expression'),\r\n                        ' catch',\r\n                        expandNode(node.error),\r\n                        '}',\r\n                    ]),\r\n                    path.call(print, 'catch'),\r\n                );\r\n            } else {\r\n                block.push(\r\n                    groupConcat(['{#await ', printSvelteBlockJS(path, print, 'expression'), '}']),\r\n                );\r\n\r\n                if (hasPendingBlock) {\r\n                    block.push(path.call(print, 'pending'));\r\n                }\r\n\r\n                if (hasThenBlock) {\r\n                    block.push(\r\n                        groupConcat(['{:then', expandNode(node.value), '}']),\r\n                        path.call(print, 'then'),\r\n                    );\r\n                }\r\n            }\r\n\r\n            if ((hasPendingBlock || hasThenBlock) && hasCatchBlock) {\r\n                block.push(\r\n                    groupConcat(['{:catch', expandNode(node.error), '}']),\r\n                    path.call(print, 'catch'),\r\n                );\r\n            }\r\n\r\n            block.push('{/await}');\r\n\r\n            return groupConcat(block);\r\n        }\r\n        case 'KeyBlock': {\r\n            const def: Doc[] = [\r\n                '{#key ',\r\n                printSvelteBlockJS(path, print, 'expression'),\r\n                '}',\r\n                printSvelteBlockChildren(path, print, options),\r\n            ];\r\n\r\n            def.push('{/key}');\r\n\r\n            return concat([groupConcat(def), breakParent]);\r\n        }\r\n        case 'ThenBlock':\r\n        case 'PendingBlock':\r\n        case 'CatchBlock':\r\n            return printSvelteBlockChildren(path, print, options);\r\n        case 'EventHandler':\r\n            return concat([\r\n                'on:',\r\n                node.name,\r\n                node.modifiers && node.modifiers.length\r\n                    ? concat(['|', join('|', node.modifiers)])\r\n                    : '',\r\n                node.expression ? concat(['=', ...printJsExpression()]) : '',\r\n            ]);\r\n        case 'Binding':\r\n            return concat([\r\n                'bind:',\r\n                node.name,\r\n                node.expression.type === 'Identifier' &&\r\n                node.expression.name === node.name &&\r\n                options.svelteAllowShorthand &&\r\n                !options.svelteStrictMode\r\n                    ? ''\r\n                    : concat(['=', ...printJsExpression()]),\r\n            ]);\r\n        case 'Class':\r\n            return concat([\r\n                'class:',\r\n                node.name,\r\n                node.expression.type === 'Identifier' &&\r\n                node.expression.name === node.name &&\r\n                options.svelteAllowShorthand &&\r\n                !options.svelteStrictMode\r\n                    ? ''\r\n                    : concat(['=', ...printJsExpression()]),\r\n            ]);\r\n        case 'StyleDirective':\r\n            const prefix = [\r\n                'style:',\r\n                node.name,\r\n                node.modifiers && node.modifiers.length\r\n                    ? concat(['|', join('|', node.modifiers)])\r\n                    : '',\r\n            ];\r\n\r\n            if (isOrCanBeConvertedToShorthand(node) || node.value === true) {\r\n                if (options.svelteStrictMode) {\r\n                    return concat([...prefix, '=\"{', node.name, '}\"']);\r\n                } else if (options.svelteAllowShorthand) {\r\n                    return concat([...prefix]);\r\n                } else {\r\n                    return concat([...prefix, '={', node.name, '}']);\r\n                }\r\n            } else {\r\n                const quotes = !isLoneMustacheTag(node.value) || options.svelteStrictMode;\r\n                const attrNodeValue = printAttributeNodeValue(path, print, quotes, node);\r\n                if (quotes) {\r\n                    return concat([...prefix, '=', '\"', attrNodeValue, '\"']);\r\n                } else {\r\n                    return concat([...prefix, '=', attrNodeValue]);\r\n                }\r\n            }\r\n        case 'Let':\r\n            return concat([\r\n                'let:',\r\n                node.name,\r\n                // shorthand let directives have `null` expressions\r\n                !node.expression ||\r\n                (node.expression.type === 'Identifier' && node.expression.name === node.name)\r\n                    ? ''\r\n                    : concat(['=', ...printJsExpression()]),\r\n            ]);\r\n        case 'DebugTag':\r\n            return concat([\r\n                '{@debug',\r\n                node.identifiers.length > 0\r\n                    ? concat([' ', join(', ', path.map(print, 'identifiers'))])\r\n                    : '',\r\n                '}',\r\n            ]);\r\n        case 'Ref':\r\n            return concat(['ref:', node.name]);\r\n        case 'Comment': {\r\n            const nodeAfterComment = getNextNode(path);\r\n\r\n            if (isIgnoreStartDirective(node) && isNodeTopLevelHTML(node, path)) {\r\n                ignoreRange = true;\r\n            } else if (isIgnoreEndDirective(node) && isNodeTopLevelHTML(node, path)) {\r\n                ignoreRange = false;\r\n            } else if (\r\n                // If there is no sibling node that starts right after us but the parent indicates\r\n                // that there used to be, that means that node was actually an embedded `<style>`\r\n                // or `<script>` node that was cut out.\r\n                // If so, the comment does not refer to the next line we will see.\r\n                // The `embed` function handles printing the comment in the right place.\r\n                doesEmbedStartAfterNode(node, path) ||\r\n                (isEmptyTextNode(nodeAfterComment) &&\r\n                    doesEmbedStartAfterNode(nodeAfterComment, path))\r\n            ) {\r\n                return '';\r\n            } else if (isIgnoreDirective(node)) {\r\n                ignoreNext = true;\r\n            }\r\n\r\n            return printComment(node);\r\n        }\r\n        case 'Transition':\r\n            const kind = node.intro && node.outro ? 'transition' : node.intro ? 'in' : 'out';\r\n            return concat([\r\n                kind,\r\n                ':',\r\n                node.name,\r\n                node.modifiers && node.modifiers.length\r\n                    ? concat(['|', join('|', node.modifiers)])\r\n                    : '',\r\n                node.expression ? concat(['=', ...printJsExpression()]) : '',\r\n            ]);\r\n        case 'Action':\r\n            return concat([\r\n                'use:',\r\n                node.name,\r\n                node.expression ? concat(['=', ...printJsExpression()]) : '',\r\n            ]);\r\n        case 'Animation':\r\n            return concat([\r\n                'animate:',\r\n                node.name,\r\n                node.expression ? concat(['=', ...printJsExpression()]) : '',\r\n            ]);\r\n        case 'RawMustacheTag':\r\n            return concat([\r\n                '{@html ',\r\n                printJS(path, print, false, false, false, 'expression'),\r\n                '}',\r\n            ]);\r\n        case 'Spread':\r\n            return concat(['{...', printJS(path, print, false, false, false, 'expression'), '}']);\r\n        case 'ConstTag':\r\n            return concat([\r\n                '{@const ',\r\n                printJS(path, print, false, false, true, 'expression'),\r\n                '}',\r\n            ]);\r\n    }\r\n\r\n    console.error(JSON.stringify(node, null, 4));\r\n    throw new Error('unknown node type: ' + node.type);\r\n}\r\n\r\nfunction assignCommentsToNodes(ast: ASTNode) {\r\n    if (ast.module) {\r\n        ast.module.comments = removeAndGetLeadingComments(ast, ast.module);\r\n    }\r\n    if (ast.instance) {\r\n        ast.instance.comments = removeAndGetLeadingComments(ast, ast.instance);\r\n    }\r\n    if (ast.css) {\r\n        ast.css.comments = removeAndGetLeadingComments(ast, ast.css);\r\n    }\r\n}\r\n\r\n/**\r\n * Returns the comments that are above the current node and deletes them from the html ast.\r\n */\r\nfunction removeAndGetLeadingComments(ast: ASTNode, current: Node): CommentInfo[] {\r\n    const siblings = getChildren(ast.html);\r\n    const comments: CommentNode[] = [];\r\n    const newlines: TextNode[] = [];\r\n\r\n    if (!siblings.length) {\r\n        return [];\r\n    }\r\n\r\n    let node: Node = current;\r\n    let prev: Node | undefined = siblings.find((child) => child.end === node.start);\r\n    while (prev) {\r\n        if (\r\n            prev.type === 'Comment' &&\r\n            !isIgnoreStartDirective(prev) &&\r\n            !isIgnoreEndDirective(prev)\r\n        ) {\r\n            comments.push(prev);\r\n            if (comments.length !== newlines.length) {\r\n                newlines.push({ type: 'Text', data: '', raw: '', start: -1, end: -1 });\r\n            }\r\n        } else if (isEmptyTextNode(prev)) {\r\n            newlines.push(prev);\r\n        } else {\r\n            break;\r\n        }\r\n\r\n        node = prev;\r\n        prev = siblings.find((child) => child.end === node.start);\r\n    }\r\n\r\n    newlines.length = comments.length; // could be one more if first comment is preceeded by empty text node\r\n\r\n    for (const comment of comments) {\r\n        siblings.splice(siblings.indexOf(comment), 1);\r\n    }\r\n\r\n    for (const text of newlines) {\r\n        siblings.splice(siblings.indexOf(text), 1);\r\n    }\r\n\r\n    return comments\r\n        .map((comment, i) => ({\r\n            comment,\r\n            emptyLineAfter: getUnencodedText(newlines[i]).split('\\n').length > 2,\r\n        }))\r\n        .reverse();\r\n}\r\n\r\nfunction printTopLevelParts(\r\n    n: ASTNode,\r\n    options: ParserOptions,\r\n    path: FastPath<any>,\r\n    print: PrintFn,\r\n): Doc {\r\n    if (options.svelteSortOrder === 'none') {\r\n        const topLevelPartsByEnd: Record<number, any> = {};\r\n\r\n        if (n.module) {\r\n            n.module.type = 'Script';\r\n            n.module.attributes = extractAttributes(getText(n.module, options));\r\n            topLevelPartsByEnd[n.module.end] = n.module;\r\n        }\r\n        if (n.instance) {\r\n            n.instance.type = 'Script';\r\n            n.instance.attributes = extractAttributes(getText(n.instance, options));\r\n            topLevelPartsByEnd[n.instance.end] = n.instance;\r\n        }\r\n        if (n.css) {\r\n            n.css.type = 'Style';\r\n            n.css.content.type = 'StyleProgram';\r\n            topLevelPartsByEnd[n.css.end] = n.css;\r\n        }\r\n\r\n        const children = getChildren(n.html);\r\n        for (let i = 0; i < children.length; i++) {\r\n            const node = children[i];\r\n            if (topLevelPartsByEnd[node.start]) {\r\n                children.splice(i, 0, topLevelPartsByEnd[node.start]);\r\n                delete topLevelPartsByEnd[node.start];\r\n            }\r\n        }\r\n\r\n        const result = path.call(print, 'html');\r\n        if (options.insertPragma && !hasPragma(options.originalText)) {\r\n            return concat([`<!-- @format -->`, hardline, result]);\r\n        } else {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    const parts: Record<SortOrderPart, Doc[]> = {\r\n        options: [],\r\n        scripts: [],\r\n        markup: [],\r\n        styles: [],\r\n    };\r\n\r\n    // scripts\r\n    if (n.module) {\r\n        n.module.type = 'Script';\r\n        n.module.attributes = extractAttributes(getText(n.module, options));\r\n        parts.scripts.push(path.call(print, 'module'));\r\n    }\r\n    if (n.instance) {\r\n        n.instance.type = 'Script';\r\n        n.instance.attributes = extractAttributes(getText(n.instance, options));\r\n        parts.scripts.push(path.call(print, 'instance'));\r\n    }\r\n\r\n    // styles\r\n    if (n.css) {\r\n        n.css.type = 'Style';\r\n        n.css.content.type = 'StyleProgram';\r\n        parts.styles.push(path.call(print, 'css'));\r\n    }\r\n\r\n    // markup\r\n    const htmlDoc = path.call(print, 'html');\r\n    if (htmlDoc) {\r\n        parts.markup.push(htmlDoc);\r\n    }\r\n    if (svelteOptionsDoc) {\r\n        parts.options.push(svelteOptionsDoc);\r\n    }\r\n\r\n    const docs = flatten(parseSortOrder(options.svelteSortOrder).map((p) => parts[p]));\r\n\r\n    // Need to reset these because they are global and could affect the next formatting run\r\n    ignoreNext = false;\r\n    ignoreRange = false;\r\n    svelteOptionsDoc = undefined;\r\n\r\n    // If this is invoked as an embed of markdown, remove the last hardline.\r\n    // The markdown parser tries this, too, but fails because it does not\r\n    // recurse into concats. Doing this will prevent an empty line\r\n    // at the end of the embedded code block.\r\n    if (options.parentParser === 'markdown') {\r\n        const lastDoc = docs[docs.length - 1];\r\n        trimRight([lastDoc], isLine);\r\n    }\r\n\r\n    if (options.insertPragma && !hasPragma(options.originalText)) {\r\n        return concat([`<!-- @format -->`, hardline, groupConcat(docs)]);\r\n    } else {\r\n        return groupConcat([join(hardline, docs)]);\r\n    }\r\n}\r\n\r\nfunction printAttributeNodeValue(\r\n    path: FastPath<any>,\r\n    print: PrintFn,\r\n    quotes: boolean,\r\n    node: AttributeNode | StyleDirectiveNode,\r\n) {\r\n    const valueDocs = path.map((childPath) => childPath.call(print), 'value');\r\n\r\n    if (!quotes || !formattableAttributes.includes(node.name)) {\r\n        return concat(valueDocs);\r\n    } else {\r\n        return indent(groupConcat(trim(valueDocs, isLine)));\r\n    }\r\n}\r\n\r\nfunction printSvelteBlockChildren(path: FastPath, print: PrintFn, options: ParserOptions): Doc {\r\n    const node = path.getValue();\r\n    const children = node.children;\r\n    if (!children || children.length === 0) {\r\n        return '';\r\n    }\r\n\r\n    const whitespaceAtStartOfBlock = checkWhitespaceAtStartOfSvelteBlock(node, options);\r\n    const whitespaceAtEndOfBlock = checkWhitespaceAtEndOfSvelteBlock(node, options);\r\n    const startline =\r\n        whitespaceAtStartOfBlock === 'none'\r\n            ? ''\r\n            : whitespaceAtEndOfBlock === 'line' || whitespaceAtStartOfBlock === 'line'\r\n            ? hardline\r\n            : line;\r\n    const endline =\r\n        whitespaceAtEndOfBlock === 'none'\r\n            ? ''\r\n            : whitespaceAtEndOfBlock === 'line' || whitespaceAtStartOfBlock === 'line'\r\n            ? hardline\r\n            : line;\r\n\r\n    const firstChild = children[0];\r\n    const lastChild = children[children.length - 1];\r\n    if (isTextNodeStartingWithWhitespace(firstChild)) {\r\n        trimTextNodeLeft(firstChild);\r\n    }\r\n    if (isTextNodeEndingWithWhitespace(lastChild)) {\r\n        trimTextNodeRight(lastChild);\r\n    }\r\n\r\n    return concat([\r\n        indent(concat([startline, group(printChildren(path, print, options))])),\r\n        endline,\r\n    ]);\r\n}\r\n\r\nfunction printPre(\r\n    node: Parameters<typeof printRaw>[0],\r\n    originalText: string,\r\n    path: FastPath,\r\n    print: PrintFn,\r\n): Doc {\r\n    const result: Doc = [];\r\n    const length = node.children.length;\r\n    for (let i = 0; i < length; i++) {\r\n        const child = node.children[i];\r\n        if (child.type === 'Text') {\r\n            const lines = originalText.substring(child.start, child.end).split(/\\r?\\n/);\r\n            lines.forEach((line, j) => {\r\n                if (j > 0) result.push(literalline);\r\n                result.push(line);\r\n            });\r\n        } else {\r\n            result.push(path.call(print, 'children', i));\r\n        }\r\n    }\r\n    return concat(result);\r\n}\r\n\r\nfunction printChildren(path: FastPath, print: PrintFn, options: ParserOptions): Doc {\r\n    if (isPreTagContent(path)) {\r\n        return concat(path.map(print, 'children'));\r\n    }\r\n\r\n    const childNodes: Node[] = prepareChildren(path.getValue().children, path, print, options);\r\n    // modify original array because it's accessed later through map(print, 'children', idx)\r\n    path.getValue().children = childNodes;\r\n    if (childNodes.length === 0) {\r\n        return '';\r\n    }\r\n\r\n    const childDocs: Doc[] = [];\r\n    let handleWhitespaceOfPrevTextNode = false;\r\n\r\n    for (let i = 0; i < childNodes.length; i++) {\r\n        const childNode = childNodes[i];\r\n        if (childNode.type === 'Text') {\r\n            handleTextChild(i, childNode);\r\n        } else if (isBlockElement(childNode, options)) {\r\n            handleBlockChild(i);\r\n        } else if (isInlineElement(path, options, childNode)) {\r\n            handleInlineChild(i);\r\n        } else {\r\n            childDocs.push(printChild(i));\r\n            handleWhitespaceOfPrevTextNode = false;\r\n        }\r\n    }\r\n\r\n    // If there's at least one block element and more than one node, break content\r\n    const forceBreakContent =\r\n        childNodes.length > 1 && childNodes.some((child) => isBlockElement(child, options));\r\n    if (forceBreakContent) {\r\n        childDocs.push(breakParent);\r\n    }\r\n\r\n    return concat(childDocs);\r\n\r\n    function printChild(idx: number): Doc {\r\n        return path.call(print, 'children', idx);\r\n    }\r\n\r\n    /**\r\n     * Print inline child. Hug whitespace of previous text child if there was one.\r\n     */\r\n    function handleInlineChild(idx: number) {\r\n        if (handleWhitespaceOfPrevTextNode) {\r\n            childDocs.push(groupConcat([line, printChild(idx)]));\r\n        } else {\r\n            childDocs.push(printChild(idx));\r\n        }\r\n        handleWhitespaceOfPrevTextNode = false;\r\n    }\r\n\r\n    /**\r\n     * Print block element. Add softlines around it if needed\r\n     * so it breaks into a separate line if children are broken up.\r\n     * Don't add lines at the start/end if it's the first/last child because this\r\n     * kind of whitespace handling is done in the parent already.\r\n     */\r\n    function handleBlockChild(idx: number) {\r\n        const prevChild = childNodes[idx - 1];\r\n        if (\r\n            prevChild &&\r\n            !isBlockElement(prevChild, options) &&\r\n            (prevChild.type !== 'Text' ||\r\n                handleWhitespaceOfPrevTextNode ||\r\n                !isTextNodeEndingWithWhitespace(prevChild))\r\n        ) {\r\n            childDocs.push(softline);\r\n        }\r\n\r\n        childDocs.push(printChild(idx));\r\n\r\n        const nextChild = childNodes[idx + 1];\r\n        if (\r\n            nextChild &&\r\n            (nextChild.type !== 'Text' ||\r\n                // Only handle text which starts with a whitespace and has text afterwards,\r\n                // or is empty but followed by an inline element. The latter is done\r\n                // so that if the children break, the inline element afterwards is in a separate line.\r\n                ((!isEmptyTextNode(nextChild) ||\r\n                    (childNodes[idx + 2] && isInlineElement(path, options, childNodes[idx + 2]))) &&\r\n                    !isTextNodeStartingWithLinebreak(nextChild)))\r\n        ) {\r\n            childDocs.push(softline);\r\n        }\r\n        handleWhitespaceOfPrevTextNode = false;\r\n    }\r\n\r\n    /**\r\n     * Print text child. First/last child white space handling\r\n     * is done in parent already. By definition of the Svelte AST,\r\n     * a text node always is inbetween other tags. Add hardlines\r\n     * if the users wants to have them inbetween.\r\n     * If the text is trimmed right, toggle flag telling\r\n     * subsequent (inline)block element to alter its printing logic\r\n     * to check if they need to hug or print lines themselves.\r\n     */\r\n    function handleTextChild(idx: number, childNode: TextNode) {\r\n        handleWhitespaceOfPrevTextNode = false;\r\n\r\n        if (idx === 0 || idx === childNodes.length - 1) {\r\n            childDocs.push(printChild(idx));\r\n            return;\r\n        }\r\n\r\n        const prevNode = childNodes[idx - 1];\r\n        const nextNode = childNodes[idx + 1];\r\n\r\n        if (\r\n            isTextNodeStartingWithWhitespace(childNode) &&\r\n            // If node is empty, go straight through to checking the right end\r\n            !isEmptyTextNode(childNode)\r\n        ) {\r\n            if (\r\n                isInlineElement(path, options, prevNode) &&\r\n                !isTextNodeStartingWithLinebreak(childNode)\r\n            ) {\r\n                trimTextNodeLeft(childNode);\r\n                const lastChildDoc = childDocs.pop()!;\r\n                childDocs.push(groupConcat([lastChildDoc, line]));\r\n            }\r\n\r\n            if (isBlockElement(prevNode, options) && !isTextNodeStartingWithLinebreak(childNode)) {\r\n                trimTextNodeLeft(childNode);\r\n            }\r\n        }\r\n\r\n        if (isTextNodeEndingWithWhitespace(childNode)) {\r\n            if (\r\n                isInlineElement(path, options, nextNode) &&\r\n                !isTextNodeEndingWithLinebreak(childNode)\r\n            ) {\r\n                handleWhitespaceOfPrevTextNode = !prevNode || !isBlockElement(prevNode, options);\r\n                trimTextNodeRight(childNode);\r\n            }\r\n            if (isBlockElement(nextNode, options) && !isTextNodeEndingWithLinebreak(childNode, 2)) {\r\n                handleWhitespaceOfPrevTextNode = !prevNode || !isBlockElement(prevNode, options);\r\n                trimTextNodeRight(childNode);\r\n            }\r\n        }\r\n\r\n        childDocs.push(printChild(idx));\r\n    }\r\n}\r\n\r\n/**\r\n * `svelte:options` is part of the html part but needs to be snipped out and handled\r\n * separately to reorder it as configured. The comment above it should be moved with it.\r\n * Do that here.\r\n */\r\nfunction prepareChildren(\r\n    children: Node[],\r\n    path: FastPath,\r\n    print: PrintFn,\r\n    options: ParserOptions,\r\n): Node[] {\r\n    let svelteOptionsComment: Doc | undefined;\r\n    const childrenWithoutOptions = [];\r\n    const bracketSameLine = isBracketSameLine(options);\r\n\r\n    for (let idx = 0; idx < children.length; idx++) {\r\n        const currentChild = children[idx];\r\n\r\n        if (currentChild.type === 'Text' && getUnencodedText(currentChild) === '') {\r\n            continue;\r\n        }\r\n\r\n        if (isEmptyTextNode(currentChild) && doesEmbedStartAfterNode(currentChild, path)) {\r\n            continue;\r\n        }\r\n\r\n        if (options.svelteSortOrder !== 'none') {\r\n            if (isCommentFollowedByOptions(currentChild, idx)) {\r\n                svelteOptionsComment = printComment(currentChild);\r\n                const nextChild = children[idx + 1];\r\n                idx += nextChild && isEmptyTextNode(nextChild) ? 1 : 0;\r\n                continue;\r\n            }\r\n\r\n            if (currentChild.type === 'Options') {\r\n                printSvelteOptions(currentChild, idx, path, print);\r\n                continue;\r\n            }\r\n        }\r\n\r\n        childrenWithoutOptions.push(currentChild);\r\n    }\r\n\r\n    const mergedChildrenWithoutOptions = [];\r\n\r\n    for (let idx = 0; idx < childrenWithoutOptions.length; idx++) {\r\n        const currentChild = childrenWithoutOptions[idx];\r\n        const nextChild = childrenWithoutOptions[idx + 1];\r\n\r\n        if (currentChild.type === 'Text' && nextChild && nextChild.type === 'Text') {\r\n            // A tag was snipped out (f.e. svelte:options). Join text\r\n            currentChild.raw += nextChild.raw;\r\n            currentChild.data += nextChild.data;\r\n            idx++;\r\n        }\r\n\r\n        mergedChildrenWithoutOptions.push(currentChild);\r\n    }\r\n\r\n    return mergedChildrenWithoutOptions;\r\n\r\n    function printSvelteOptions(\r\n        node: OptionsNode,\r\n        idx: number,\r\n        path: FastPath,\r\n        print: PrintFn,\r\n    ): void {\r\n        svelteOptionsDoc = groupConcat([\r\n            groupConcat([\r\n                '<',\r\n                node.name,\r\n                indent(\r\n                    groupConcat([\r\n                        ...path.map(\r\n                            printWithPrependedAttributeLine(node, options, print),\r\n                            'children',\r\n                            idx,\r\n                            'attributes',\r\n                        ),\r\n                        bracketSameLine ? '' : dedent(line),\r\n                    ]),\r\n                ),\r\n                ...[bracketSameLine ? ' ' : '', '/>'],\r\n            ]),\r\n            hardline,\r\n        ]);\r\n        if (svelteOptionsComment) {\r\n            svelteOptionsDoc = groupConcat([svelteOptionsComment, hardline, svelteOptionsDoc]);\r\n        }\r\n    }\r\n\r\n    function isCommentFollowedByOptions(node: Node, idx: number): node is CommentNode {\r\n        if (node.type !== 'Comment' || isIgnoreEndDirective(node) || isIgnoreStartDirective(node)) {\r\n            return false;\r\n        }\r\n\r\n        const nextChild = children[idx + 1];\r\n        if (nextChild) {\r\n            if (isEmptyTextNode(nextChild)) {\r\n                const afterNext = children[idx + 2];\r\n                return afterNext && afterNext.type === 'Options';\r\n            }\r\n            return nextChild.type === 'Options';\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Split the text into words separated by whitespace. Replace the whitespaces by lines,\r\n * collapsing multiple whitespaces into a single line.\r\n *\r\n * If the text starts or ends with multiple newlines, two of those should be kept.\r\n */\r\nfunction splitTextToDocs(node: TextNode): Doc[] {\r\n    const text = getUnencodedText(node);\r\n    let docs: Doc[] = text.split(/[\\t\\n\\f\\r ]+/);\r\n\r\n    docs = join(line, docs).parts.filter((s) => s !== '');\r\n\r\n    if (startsWithLinebreak(text)) {\r\n        docs[0] = hardline;\r\n    }\r\n    if (startsWithLinebreak(text, 2)) {\r\n        docs = [hardline, ...docs];\r\n    }\r\n\r\n    if (endsWithLinebreak(text)) {\r\n        docs[docs.length - 1] = hardline;\r\n    }\r\n    if (endsWithLinebreak(text, 2)) {\r\n        docs = [...docs, hardline];\r\n    }\r\n\r\n    return docs;\r\n}\r\n\r\nfunction printSvelteBlockJS(path: FastPath, print: PrintFn, name: string) {\r\n    return printJS(path, print, false, true, false, name);\r\n}\r\n\r\nfunction printJS(\r\n    path: FastPath,\r\n    print: PrintFn,\r\n    forceSingleQuote: boolean,\r\n    forceSingleLine: boolean,\r\n    removeParentheses: boolean,\r\n    name: string,\r\n) {\r\n    path.getValue()[name].isJS = true;\r\n    path.getValue()[name].forceSingleQuote = forceSingleQuote;\r\n    path.getValue()[name].forceSingleLine = forceSingleLine;\r\n    path.getValue()[name].removeParentheses = removeParentheses;\r\n    return path.call(print, name);\r\n}\r\n\r\nfunction expandNode(node: any, parent?: any): string {\r\n    if (node === null) {\r\n        return '';\r\n    }\r\n\r\n    if (typeof node === 'string') {\r\n        // pre-v3.20 AST\r\n        return ' ' + node;\r\n    }\r\n\r\n    switch (node.type) {\r\n        case 'ArrayExpression':\r\n        case 'ArrayPattern':\r\n            return ' [' + node.elements.map(expandNode).join(',').slice(1) + ']';\r\n        case 'AssignmentPattern':\r\n            return expandNode(node.left) + ' =' + expandNode(node.right);\r\n        case 'Identifier':\r\n            return ' ' + node.name;\r\n        case 'Literal':\r\n            return ' ' + node.raw;\r\n        case 'ObjectExpression':\r\n            return ' {' + node.properties.map((p: any) => expandNode(p, node)).join(',') + ' }';\r\n        case 'ObjectPattern':\r\n            return ' {' + node.properties.map(expandNode).join(',') + ' }';\r\n        case 'Property':\r\n            if (node.value.type === 'ObjectPattern' || node.value.type === 'ArrayPattern') {\r\n                return ' ' + node.key.name + ':' + expandNode(node.value);\r\n            } else if (\r\n                (node.value.type === 'Identifier' && node.key.name !== node.value.name) ||\r\n                (parent && parent.type === 'ObjectExpression')\r\n            ) {\r\n                return expandNode(node.key) + ':' + expandNode(node.value);\r\n            } else {\r\n                return expandNode(node.value);\r\n            }\r\n        case 'RestElement':\r\n            return ' ...' + node.argument.name;\r\n    }\r\n\r\n    console.error(JSON.stringify(node, null, 4));\r\n    throw new Error('unknown node type: ' + node.type);\r\n}\r\n\r\nfunction printComment(node: CommentNode) {\r\n    let text = node.data;\r\n\r\n    if (hasSnippedContent(text)) {\r\n        text = unsnipContent(text);\r\n    }\r\n\r\n    return groupConcat(['<!--', text, '-->']);\r\n}\r\n","import { Doc, doc, FastPath, ParserOptions } from 'prettier';\r\nimport { getText } from './lib/getText';\r\nimport { snippedTagContentAttribute } from './lib/snipTagContent';\r\nimport { isBracketSameLine } from './options';\r\nimport { PrintFn } from './print';\r\nimport { isLine, removeParentheses, trimRight } from './print/doc-helpers';\r\nimport { groupConcat, printWithPrependedAttributeLine } from './print/helpers';\r\nimport {\r\n    getAttributeTextValue,\r\n    getLeadingComment,\r\n    isIgnoreDirective,\r\n    isNodeSupportedLanguage,\r\n    isPugTemplate,\r\n    isTypeScript,\r\n    printRaw,\r\n} from './print/node-helpers';\r\nimport { CommentNode, ElementNode, Node, ScriptNode, StyleNode } from './print/nodes';\r\n\r\nconst {\r\n    builders: { concat, hardline, softline, indent, dedent, literalline },\r\n    utils: { removeLines },\r\n} = doc;\r\n\r\nexport function embed(\r\n    path: FastPath,\r\n    print: PrintFn,\r\n    textToDoc: (text: string, options: object) => Doc,\r\n    options: ParserOptions,\r\n): Doc | null {\r\n    const node: Node = path.getNode();\r\n\r\n    if (node.isJS) {\r\n        try {\r\n            const embeddedOptions: any = {\r\n                parser: expressionParser,\r\n            };\r\n            if (node.forceSingleQuote) {\r\n                embeddedOptions.singleQuote = true;\r\n            }\r\n\r\n            let docs = textToDoc(\r\n                forceIntoExpression(\r\n                    // If we have snipped content, it was done wrongly and we need to unsnip it.\r\n                    // This happens for example for {@html `<script>{foo}</script>`}\r\n                    getText(node, options, true),\r\n                ),\r\n                embeddedOptions,\r\n            );\r\n            if (node.forceSingleLine) {\r\n                docs = removeLines(docs);\r\n            }\r\n            if (node.removeParentheses) {\r\n                docs = removeParentheses(docs);\r\n            }\r\n            return docs;\r\n        } catch (e) {\r\n            return getText(node, options, true);\r\n        }\r\n    }\r\n\r\n    const embedType = (\r\n        tag: 'script' | 'style' | 'template',\r\n        parser: 'typescript' | 'babel-ts' | 'css' | 'pug',\r\n        isTopLevel: boolean,\r\n    ) =>\r\n        embedTag(\r\n            tag,\r\n            options.originalText,\r\n            path,\r\n            (content) => formatBodyContent(content, parser, textToDoc, options),\r\n            print,\r\n            isTopLevel,\r\n            options,\r\n        );\r\n\r\n    const embedScript = (isTopLevel: boolean) =>\r\n        embedType(\r\n            'script',\r\n            // Use babel-ts as fallback because the absence does not mean the content is not TS,\r\n            // the user could have set the default language. babel-ts will format things a little\r\n            // bit different though, especially preserving parentheses around dot notation which\r\n            // fixes https://github.com/sveltejs/prettier-plugin-svelte/issues/218\r\n            isTypeScript(node) ? 'typescript' : 'babel-ts',\r\n            isTopLevel,\r\n        );\r\n    const embedStyle = (isTopLevel: boolean) => embedType('style', 'css', isTopLevel);\r\n    const embedPug = () => embedType('template', 'pug', false);\r\n\r\n    switch (node.type) {\r\n        case 'Script':\r\n            return embedScript(true);\r\n        case 'Style':\r\n            return embedStyle(true);\r\n        case 'Element': {\r\n            if (node.name === 'script') {\r\n                return embedScript(false);\r\n            } else if (node.name === 'style') {\r\n                return embedStyle(false);\r\n            } else if (isPugTemplate(node)) {\r\n                return embedPug();\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nfunction forceIntoExpression(statement: string) {\r\n    // note the trailing newline: if the statement ends in a // comment,\r\n    // we can't add the closing bracket right afterwards\r\n    return `(${statement}\\n)`;\r\n}\r\n\r\nfunction expressionParser(text: string, parsers: any, options: any) {\r\n    const ast = parsers.babel(text, parsers, options);\r\n\r\n    return { ...ast, program: ast.program.body[0].expression };\r\n}\r\n\r\nfunction preformattedBody(str: string): Doc {\r\n    const firstNewline = /^[\\t\\f\\r ]*\\n/;\r\n    const lastNewline = /\\n[\\t\\f\\r ]*$/;\r\n\r\n    // If we do not start with a new line prettier might try to break the opening tag\r\n    // to keep it together with the string. Use a literal line to skip indentation.\r\n    return concat([literalline, str.replace(firstNewline, '').replace(lastNewline, ''), hardline]);\r\n}\r\n\r\nfunction getSnippedContent(node: Node) {\r\n    const encodedContent = getAttributeTextValue(snippedTagContentAttribute, node);\r\n\r\n    if (encodedContent) {\r\n        return Buffer.from(encodedContent, 'base64').toString('utf-8');\r\n    } else {\r\n        return '';\r\n    }\r\n}\r\n\r\nfunction formatBodyContent(\r\n    content: string,\r\n    parser: 'typescript' | 'babel-ts' | 'css' | 'pug',\r\n    textToDoc: (text: string, options: object) => Doc,\r\n    options: ParserOptions & { pugTabWidth?: number },\r\n) {\r\n    try {\r\n        const body = textToDoc(content, { parser });\r\n\r\n        if (parser === 'pug' && typeof body === 'string') {\r\n            // Pug returns no docs but a final string.\r\n            // Therefore prepend the line offsets\r\n            const whitespace = options.useTabs\r\n                ? '\\t'\r\n                : ' '.repeat(\r\n                      options.pugTabWidth && options.pugTabWidth > 0\r\n                          ? options.pugTabWidth\r\n                          : options.tabWidth,\r\n                  );\r\n            const pugBody = body\r\n                .split('\\n')\r\n                .map((line) => (line ? whitespace + line : line))\r\n                .join('\\n');\r\n            return concat([hardline, pugBody]);\r\n        }\r\n\r\n        const indentIfDesired = (doc: Doc) =>\r\n            options.svelteIndentScriptAndStyle ? indent(doc) : doc;\r\n        trimRight([body], isLine);\r\n        return concat([indentIfDesired(concat([hardline, body])), hardline]);\r\n    } catch (error) {\r\n        if (process.env.PRETTIER_DEBUG) {\r\n            throw error;\r\n        }\r\n\r\n        // We will wind up here if there is a syntax error in the embedded code. If we throw an error,\r\n        // prettier will try to print the node with the printer. That will fail with a hard-to-interpret\r\n        // error message (e.g. \"Unsupported node type\", referring to `<script>`).\r\n        // Therefore, fall back on just returning the unformatted text.\r\n        console.error(error);\r\n\r\n        return preformattedBody(content);\r\n    }\r\n}\r\n\r\nfunction embedTag(\r\n    tag: 'script' | 'style' | 'template',\r\n    text: string,\r\n    path: FastPath,\r\n    formatBodyContent: (content: string) => Doc,\r\n    print: PrintFn,\r\n    isTopLevel: boolean,\r\n    options: ParserOptions,\r\n) {\r\n    const node: ScriptNode | StyleNode | ElementNode = path.getNode();\r\n    const content =\r\n        tag === 'template' ? printRaw(node as ElementNode, text) : getSnippedContent(node);\r\n    const previousComments =\r\n        node.type === 'Script' || node.type === 'Style'\r\n            ? node.comments\r\n            : [getLeadingComment(path)]\r\n                  .filter(Boolean)\r\n                  .map((comment) => ({ comment: comment as CommentNode, emptyLineAfter: false }));\r\n\r\n    const canFormat =\r\n        isNodeSupportedLanguage(node) &&\r\n        !isIgnoreDirective(previousComments[previousComments.length - 1]?.comment) &&\r\n        (tag !== 'template' ||\r\n            options.plugins.some(\r\n                (plugin) => typeof plugin !== 'string' && plugin.parsers && plugin.parsers.pug,\r\n            ));\r\n    const body: Doc = canFormat\r\n        ? content.trim() !== ''\r\n            ? formatBodyContent(content)\r\n            : content === ''\r\n            ? ''\r\n            : hardline\r\n        : preformattedBody(content);\r\n\r\n    const openingTag = groupConcat([\r\n        '<',\r\n        tag,\r\n        indent(\r\n            groupConcat([\r\n                ...path.map(printWithPrependedAttributeLine(node, options, print), 'attributes'),\r\n                isBracketSameLine(options) ? '' : dedent(softline),\r\n            ]),\r\n        ),\r\n        '>',\r\n    ]);\r\n    let result = groupConcat([openingTag, body, '</', tag, '>']);\r\n\r\n    const comments = [];\r\n    for (const comment of previousComments) {\r\n        comments.push('<!--', comment.comment.data, '-->');\r\n        comments.push(hardline);\r\n        if (comment.emptyLineAfter) {\r\n            comments.push(hardline);\r\n        }\r\n    }\r\n\r\n    if (isTopLevel && options.svelteSortOrder !== 'none') {\r\n        // top level embedded nodes have been moved from their normal position in the\r\n        // node tree. if there is a comment referring to it, it must be recreated at\r\n        // the new position.\r\n        return concat([...comments, result, hardline]);\r\n    } else {\r\n        return comments.length ? concat([...comments, result]) : result;\r\n    }\r\n}\r\n","import { SupportLanguage, Parser, Printer } from 'prettier';\r\nimport { hasPragma, print } from './print';\r\nimport { ASTNode } from './print/nodes';\r\nimport { embed } from './embed';\r\nimport { snipScriptAndStyleTagContent } from './lib/snipTagContent';\r\n\r\nfunction locStart(node: any) {\r\n    return node.start;\r\n}\r\n\r\nfunction locEnd(node: any) {\r\n    return node.end;\r\n}\r\n\r\nexport const languages: Partial<SupportLanguage>[] = [\r\n    {\r\n        name: 'svelte',\r\n        parsers: ['svelte'],\r\n        extensions: ['.svelte'],\r\n        vscodeLanguageIds: ['svelte'],\r\n    },\r\n];\r\n\r\nexport const parsers: Record<string, Parser> = {\r\n    svelte: {\r\n        hasPragma,\r\n        parse: (text) => {\r\n            try {\r\n                return <ASTNode>{ ...require(`svelte/compiler`).parse(text), __isRoot: true };\r\n            } catch (err: any) {\r\n                if (err.start != null && err.end != null) {\r\n                    // Prettier expects error objects to have loc.start and loc.end fields.\r\n                    // Svelte uses start and end directly on the error.\r\n                    err.loc = {\r\n                        start: err.start,\r\n                        end: err.end,\r\n                    };\r\n                }\r\n\r\n                throw err;\r\n            }\r\n        },\r\n        preprocess: (text, options) => {\r\n            text = snipScriptAndStyleTagContent(text);\r\n            text = text.trim();\r\n            // Prettier sets the preprocessed text as the originalText in case\r\n            // the Svelte formatter is called directly. In case it's called\r\n            // as an embedded parser (for example when there's a Svelte code block\r\n            // inside markdown), the originalText is not updated after preprocessing.\r\n            // Therefore we do it ourselves here.\r\n            options.originalText = text;\r\n            return text;\r\n        },\r\n        locStart,\r\n        locEnd,\r\n        astFormat: 'svelte-ast',\r\n    },\r\n};\r\n\r\nexport const printers: Record<string, Printer> = {\r\n    'svelte-ast': {\r\n        print,\r\n        embed,\r\n    },\r\n};\r\n\r\nexport { options } from './options';\r\n"],"names":["doc","concat","hardline","softline","indent","dedent","literalline"],"mappings":"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"}